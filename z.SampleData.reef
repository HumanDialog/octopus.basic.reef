
context App::ClearData
post:
    self.Groups.forAll( element.Lists.forAll(list: TaskList| list.Tasks.removeAll and list.AllTasks.removeAll)
                        element.Lists.removeAll
                        element.AllLists.forAll(list: TaskList| list.Tasks.removeAll and list.AllTasks.removeAll)
                        element.AllLists.removeAll
                        element.Members.removeAll)
    self.Groups.removeAll
    self.Users.removeAll


context App::ResetDemoData
post:
    self.PublicGroups.forAll(   element.Lists.forAll(list: TaskList| list.Tasks.removeAll and list.AllTasks.removeAll)
                                element.Lists.removeAll
                                element.AllLists.forAll(list: TaskList| list.Tasks.removeAll and list.AllTasks.removeAll)
                                element.AllLists.removeAll
                                element.Members.removeAll)
    self.PublicGroups.removeAll

    -- -------------------- Home group --------------------------
    let homeGroup: Group = new Group
    homeGroup.IsPublic = true
    homeGroup.Name = 'My home group'
    homeGroup.Lists.removeAll
    
    homeGroup.AllTags = "#urgent #grocery #dairy #beauty #clothes #party"

    -- Add some data
    let list: TaskList in
    list = homeGroup.Lists.newElement(element.Order = 0)
    
    let states: JsonObject = [
        {
            name: 'Required',
            state: 0
        },
        {
            name: 'Running out',
            state: 100
        },
        {
            name: 'Delivering',
            state: STATE_FINISHED
        }
    ]

    list.TaskStates = states.ToString()

    list.Name = "Shopping list"
    list.IndexPrefix = 'SHP'
        list.CreateTask('Butter', 'Buy a few on promotion', 0, '#urgent #grocery #dairy')
        list.CreateTask('Milk', 'As fat as you can', 0, '#grocery #dairy')   
        list.CreateTask('Bread', 'Take three, two of them will be frozen', 100, '#urgent #grocery')
        list.CreateTask('Tomatos', '', 0, '#grocery #party');
        list.CreateTask('Lettuce', 'Must be fresh!', 0, '#grocery #party')
        list.CreateTask('Beer', "Hefeweizens and Pilsners only, they don't drink modern styles", STATE_FINISHED, '#grocery #party')
        list.CreateTask('Honey', "It's needed for outmeal", STATE_FINISHED, '#grocery')
        list.CreateTask('Toothpaste', '', 100, '#beauty')
        list.CreateTask('Shower gel', '', 100, '#beauty')
        list.CreateTask('Sneakers', "It's already spring, I need new shoes", 3, '#urgent #clothes')
    list.ReorderTasks()

    list = homeGroup.Lists.newElement(element.Order = 10)
    list.Name = "Movies to watch" 
    list.IndexPrefix = 'MVS'
        list.CreateTask('From Dusk Till Dawn', '', 0)
        list.CreateTask('The Lion King', '', 0)
        list.CreateTask('Back to the Future', '', 0)
    list.ReorderTasks()
    
    list = homeGroup.Lists.newElement(element.Order = 20)
    list.Name = "Places to visit" 
    list.IndexPrefix = 'PLC'
        list.CreateTask('Paris', '', 0)
        list.CreateTask('Swiss Alps', '', 0)
        list.CreateTask('Bora Bora', '', 0)
        list.CreateTask('Rio de Janeiro', '', 0)
    list.ReorderTasks()
    


    ------------------------------  Dreams group -------------------------------

    let dreamsGroup: Group = new Group
    dreamsGroup.IsPublic = true
    dreamsGroup.Name = 'My dreams group'
    dreamsGroup.Lists.removeAll
    
    -- Add some data
    list = dreamsGroup.Lists.newElement(element.Order = 0)
    list.Name = "Actors to meet" 
    list.IndexPrefix = 'ACT'
        list.CreateTask('Jim Carrey', '', 0)
        list.CreateTask('Tobey Maguire', '', 0)
        list.CreateTask('Dwayne Johnson', '', 0)
        list.CreateTask('Chris Evans', '', 0)
        list.CreateTask('Ice Cube', '', 0)
        list.CreateTask('Chris Rock', '', 0)
    list.ReorderTasks()
    
    list = dreamsGroup.Lists.newElement(element.Order = 20)
    list.Name = "Cars to buy" 
    list.IndexPrefix = 'CAR'
        list.CreateTask('Aston Martin DB5', '', 0)
        list.CreateTask('DeLorean DMC-12', '', 0)
        list.CreateTask('Mustang GT 390', '', 0)
        list.CreateTask('Ford Torino', '', 0)
    list.ReorderTasks()




context App::InitSample
post:
    self.ClearData()
   
    self.ResetDemoData()

    -- Add sample users
    let alice: User = new User in
    alice.login = "alice@example.com"
    alice.Name = "Alice"
    
    alice.CheckFolders
    
    let bob: User = new User in
    bob.login = "bob@example.com"
    bob.Name = "Bob"

    bob.CheckFolders
    
    -- -------------------- Motorcycle's production --------------------------
    let motorcycleCompany: Group = new Group
    motorcycleCompany.Name = "Motorcycle's production"
    motorcycleCompany.Lists.removeAll
    motorcycleCompany.AddUser(alice)
    motorcycleCompany.AddUser(bob)

    motorcycleCompany.AllTags = "#urgent #bug #feature #prototype"
    
    motorcycleCompany.CheckFolders

    -- Add some data
    let list: TaskList in
    list = motorcycleCompany.Lists.newElement(element.Order = 0)
    
    -- list.TaskStates = '[{"name":"Required","state":0},{"name":"Running out","state":100},{"name":"Delivering","state":1000}]'
    let states: JsonObject = [
        {
            name: 'Preparing',
            state: 0
        },
        {
            name: 'In progress',
            state: 100
        },
        {
            name: 'Done',
            state: STATE_FINISHED
        }
    ]

    list.TaskStates = states.ToString()

    list.Name = "Design"
    list.IndexPrefix = 'DGN'
        list.CreateTask('Target Audience Definition', 'Identify the specific demographics and needs of the intended buyers', STATE_FINISHED, '#urgent', alice)
            
            list.Tasks.last.Description = '<h1>Description with images</h1>
            <p>Deer</p>
            <img alt="Deer" src="" data-path="group/Lists/19/Tasks/38/Images/blob?key=deer.jpg"/>
            <p>Flowers</p>
            <img alt="Flowers" src="" data-path="group/Lists/19/Tasks/38/Images/blob?key=flowers.png"/>
            <p>Tree</p>
            <img alt="Tree" src="" data-path="group/Lists/19/Tasks/38/Images/blob?key=tree.webp"/>
            '
            list.Tasks.last.Images = 'deer.jpg;flowers.png;tree.webp'

        list.CreateTask('Design Goals', 'Establish core objectives (e.g., performance, style, price range, features).', STATE_FINISHED, '', alice)   
        list.CreateTask('Concept Design', 'Create initial sketches and 3D models of the motorcycle.', 100, '#prototype', alice)
        list.CreateTask('Engineering Design', 'Develop detailed technical specifications, including frame, engine, and suspension.', 0, '#prototype');
        list.CreateTask('Ergonomics Testing', 'Ensure the motorcycle provides a comfortable and functional ride for the target user.', 0, '#prototype')
        list.CreateTask('Prototype Development', "Build a working prototype to test the design and functionality", 0, '#prototype')
    list.ReorderTasks()

    list = motorcycleCompany.Lists.newElement(element.Order = 10)
    list.Name = "Engineering" 
    list.IndexPrefix = 'ENG'
        list.CreateTask('Performance Testing', 'Test the prototype for speed, handling, durability, and efficiency.', 0)
        list.CreateTask('Safety Testing', 'Ensure compliance with safety regulations and conduct crash tests where necessary.', 0)
        list.CreateTask('Environmental Compliance', 'Meet emissions standards and other environmental regulations.', 0)
        list.CreateTask('Refinement', 'Address issues identified during testing, including mechanical, aesthetic, and ergonomic concerns.', 0)
    list.ReorderTasks()
    
    list = motorcycleCompany.Lists.newElement(element.Order = 20)
    list.Name = "Branding" 
    list.IndexPrefix = 'BRD'
        list.CreateTask('Product Naming and Branding', 'Develop a name, logo, and identity for the new motorcycle.', 0)
        list.CreateTask('Marketing Strategy', 'Plan campaigns, including online, print, and event-based marketing.', 0)
        list.CreateTask('Customer Engagement', 'Organize focus groups or pre-launch surveys to gather feedback.', 0)
        list.CreateTask('Dealer Partnerships', 'Establish relationships with dealerships or distributors for sales.', 0)
    list.ReorderTasks()
    
    

    ------------------------------  Publishing company -------------------------------

    let publishingCompany: Group = new Group
    publishingCompany.Name = 'Publishing company'
    publishingCompany.Lists.removeAll
    publishingCompany.AddUser(alice)
    publishingCompany.AddUser(bob)

    publishingCompany.CheckFolders

    -- Add some data
    list = publishingCompany.Lists.newElement(element.Order = 0)
    list.Name = "Publishing" 
    list.IndexPrefix = 'PUB'
        list.CreateTask('Writing', '', 0)
        list.CreateTask('Editing', '', 0)
        list.CreateTask('Typesetting', '', 0)
        list.CreateTask('Cover design', '', 0)
        list.CreateTask('ISBN', '', 0)
        list.CreateTask('Copyright', '', 0)
    list.ReorderTasks()
    
    list = publishingCompany.Lists.newElement(element.Order = 20)
    list.Name = "Marketing and Sales" 
    list.IndexPrefix = 'MAS'
        list.CreateTask('Promotion plan', '', 0)
        list.CreateTask('Promo materials', '', 0)
        list.CreateTask('Contact with media', '', 0)
        list.CreateTask('Book launch', '', 0)
        list.CreateTask('Choosing sales platforms', '', 0)
        list.CreateTask('Shipping logistics', '', 0)
    list.ReorderTasks()



context TaskList::ReorderTasks()
post:
    let order: integer = MIN_USER_TASK_ORDER in
    self.Tasks.orderedBy('ListOrder').forAll(element.ListOrder = order and order = order + 1)
    order = (order - MIN_USER_TASK_ORDER) * ORDER_STEP
    self.Tasks.orderedBy('ListOrder').revForAll(element.ListOrder = order and order = order - ORDER_STEP)



context Group::AddUser(u: User)
pre:
    u <> null
post:
    self.Members.newElement(element.User = u)


context Group::CheckFolder(Title: string)
post:
    if not self.Folders.select(e | e.Title = Title).exists then
        let f: Folder = self.Folders.newElement(e | e.Title = Title) in
        f.CreateSubFolders(3)
        f.CreateTasks(5)
        f.CreateNotes(4)    
        f.ReorderElements()          
    end if
    
context Group::CheckFolders
post:
    self.CheckFolder("Notes")
    self.CheckFolder("Projects")
    self.CheckFolder("Ideas")    
    

context Group::DeleteAllFolders
post:
    self.AllFolders.removeAll    


context User::CheckFolder(Title: string)
post:
    if not self.Folders.select(e | e.Title = Title).exists then
        let f: Folder = self.Folders.newElement(e | e.Title = Title) in
        f.CreateSubFolders(3)
        f.CreateTasks(3)
        f.CreateNotes(3)    
        f.ReorderElements()         
    end if
    
context Folder::CreateSubFolders(no: integer)
post:
    set(1 .. no).forAll(i | self.CreateSubFolder(self.Title + " F" + i))

    
context Folder::CreateSubFolder(Title: string)
post:
    let subfolder: Folder = new Folder in
    subfolder.Title = Title     
    self.Folders.newElement(ff| ff.Folder = subfolder)    
    
context Folder::CreateNotes(no: integer)
post:
    set(1 .. no).forAll(i | self.CreateNote(self.Title + " Note " + i))
    
context Folder::CreateNote(Title: string)
post:
    let note: Note = new Note in
    note.Title = Title     
    self.Notes.newElement(nn | nn.Note = note)    
   
context Folder::CreateTasks(no: integer)
post:
    set(1 .. no).forAll(i | self.CreateTask(self.Title + " Task " + i))
    
context Folder::CreateTask(Title: string)
post:
    let task: Task = new Task in
    task.Title = Title     
    self.Tasks.newElement(tt | tt.Task = task)      
        
    
context User::CheckFolders
post:
    self.CheckFolder("My Notes")
    self.CheckFolder("My Projects")
    self.CheckFolder("My Ideas") 
    self.GetBasketFolder() 
    self.GetPinnedFolders()      
    self.ReorderFolders()     

context User::ReorderFolders()
post:
    let order: integer = MIN_USER_TASK_ORDER in
    self.Folders.orderedBy('Order').forAll(element.Order = order and order = order + 1)
    order = (order - MIN_USER_TASK_ORDER) * ORDER_STEP
    self.Folders.orderedBy('Order').revForAll(element.Order = order and order = order - ORDER_STEP)


context Folder::ReorderSubFolders()
post:
    let order: integer = MIN_USER_TASK_ORDER in
    self.Folders.orderedBy('Order').forAll(element.Order = order and order = order + 1)
    order = (order - MIN_USER_TASK_ORDER) * ORDER_STEP
    self.Folders.orderedBy('Order').revForAll(element.Order = order and order = order - ORDER_STEP)


context Folder::ReorderNotes()
post:
    let order: integer = MIN_USER_TASK_ORDER in
    self.Notes.orderedBy('Order').forAll(element.Order = order and order = order + 1)
    order = (order - MIN_USER_TASK_ORDER) * ORDER_STEP
    self.Notes.orderedBy('Order').revForAll(element.Order = order and order = order - ORDER_STEP)


context Folder::ReorderTasks()
post:
    let order: integer = MIN_USER_TASK_ORDER in
    self.Tasks.orderedBy('Order').forAll(element.Order = order and order = order + 1)
    order = (order - MIN_USER_TASK_ORDER) * ORDER_STEP
    self.Tasks.orderedBy('Order').revForAll(element.Order = order and order = order - ORDER_STEP)

context Folder::ReorderElements()
post:
    self.ReorderSubFolders()
    self.ReorderNotes()
    self.ReorderTasks()


--TESTY
context App::Tuple: string
post:
    let b: string = 'blue' in
    let y: string = 'yellow' in
    let s: string in
    let object: JsonObject in
    let labels: JsonObject in 
    let bwlabels: JsonObject in
 
    labels = ['X','Y','Z','A','B','C','D','E']   
    labels = ['red_label', 'green_label']
    bwlabels = [{a:'white_label', b:'black_label'}]   
            
    labels = [..., b + '_label', y + '_label', ...bwlabels]        
    
    object = {
        title: b + '/' + y,
        labels: ...labels
    }

    s = object.ToString
    result = s 
    
    
context App::Res: string
post:
    let s: string = 'blue' in
    let i: integer = 1000 in
    let json: JsonObject = new JsonObject in
    let jarray: JsonObject = new JsonObject in
    let labels: JsonObject in 
    
    json = {
            property1:      s + ' sky', 
            2:              "two", 
            "property 3":   "three",
            values:         [1,2,3*i,4,5,6,7,8,9,0],
            colors:         ['red', 'green', s],
            "my cars":      [
                {
                    model  :'Passat',
                    power  :   10
                },
                {
                    model  :'Golf',
                    power  :   7
                }
            ] 
            }
            
    labels = new JsonObject        
    labels = ['label_red', 'label_green', 'label_' + s]        
    jarray = [
                {
                    model  :'Picasso',
                    power  :   10
                },
                {
                    model  :'Megane',
                    power  :   7
                }
            ] 

    let body: JsonObject in
    body = {
        Content: {
            Simple: {
                Body: {
                    Text: {
                        Charset: "UTF-8",
                        Data: "Hello from ObjectReef service"
                    }
                },
                Subject: {
                    Charset: "UTF-8",
                    Data: "Hello"
                }
            }
        },
        Destination: {
            ToAddresses: ["swobodny.elektron@gmail.com"]
        },
        FromEmailAddress: "noreply@objectreef.dev"
    }
    
            
    --s = json.property1         
    --i = json['my cars'].count        
    --json['my cars'].forAll(s = s + element.model)
    --s = json['my cars'].at(1).model
    --s = json.ToString        
    --i = json.values.count
    --i = json.values[2]
    --s = json['my cars'][1].model --puste - ok
    let property: string = 'color' in
    let index: integer = 1  in 
    s = json[property][index]
    
    let models: string  in 
    json['my cars'].forAll(models = models + element.model)
    s = '1: ' + json.property1 + ", 2: " + json[property +'s'][index + 1] + ", 3: " + labels[2] + ", 4: " + json['my cars'].count + ", 5: " + models + ", 6: " + json['my cars'].at(1).model + ", 7: " + jarray.at(1).model + ", 8: " +  json.values.count + ", 9: " + json.values[2]
    --s = jarray.at(1).model
    result = s   

    context TaskList::Test2(): JsonObject
post:
    let states: JsonObject = new JsonObject
    states.Parse(self.TaskStates)
    result = states

context TaskList::Test: JsonBuilder
post:
    let states: JsonObject = new JsonObject
    states.Parse(self.TaskStates)

    let i: integer
    

    let builder: JsonBuilder = new JsonBuilder
    builder.StartTable()
        states.forAll(
            builder.StartObject()
                i = element.state
                builder.PushKey("state").PushInteger(i)
                builder.PushKey("name").PushString(element.name)
            builder.EndObject()
        )
    builder.EndTable()

    result = builder

context TaskList::AddColumn2(): JsonBuilder
post:
    let states: JsonObject = new JsonObject
    states.Parse(self.TaskStates)

    let builder: JsonBuilder = new JsonBuilder
    let newState :integer = states.select(element.state < 1000).max(element.state) + 1

    builder.StartTable()
        states.select(element.state < 1000).forAll(
            builder.StartObject()
                builder.PushKey("state").PushInteger(element.state)
                builder.PushKey("name").PushString(element.name)
            builder.EndObject()
        )

        builder.StartObject()
            builder.PushKey("state").PushInteger(newState)
            builder.PushKey("name").PushString('Nowa')
        builder.EndObject()

        states.select(element.state >= 1000).forAll(
            builder.StartObject()
                builder.PushKey("state").PushInteger(element.state)
                builder.PushKey("name").PushString(element.name)
            builder.EndObject()
        )

    builder.EndTable()

    result = builder

context TaskList::AddColumn3(): string
post:
    let states: JsonObject = new JsonObject
    states.Parse(self.TaskStates)

    let newColumn: JsonObject = {
        name: 'New',
        state: 555
    }

    let r: JsonObject = [..., newColumn]
    result = r.ToString
    
context TaskList::AddColumn4(): string
post:
    let states: JsonObject = new JsonObject
    states.Parse(self.TaskStates)

    let newColumn: JsonObject = [{
        name: 'New',
        state: 555
    }]

    let r: JsonObject
    r = states[1]
    r = [..., ...newColumn]
    result = r.ToString

context TaskList::AddColumn4a(): string
post:
    let states: JsonObject = new JsonObject
    states.Parse(self.TaskStates)

    let newColumn: JsonObject = [{
        name: 'New',
        state: 555
    }]

    let r: JsonObject = []
    let a: JsonObject
    states.forAll(  a=[{state: element.state, name: element.name }] 
                    r=[...,...a])

    r = [..., ...newColumn]
    result = r.ToString    

context TaskList::AddColumn5(): string
post:
    let states: JsonObject = [
        {
            name: 'A',
            state: 0
        },
        {
            name: 'B',
            state: 1
        }
    ]

    let newColumn: JsonObject = [{
        name: 'New',
        state: 555
    }]

    let r: JsonObject
    r = states
    r = [..., ...newColumn]
    result = r.ToString

context TaskList::AddColumnX(): JsonBuilder
post:
    let states: JsonObject = new JsonObject
    states.Parse(self.TaskStates)

    let builder: JsonBuilder = new JsonBuilder
    let newState :integer = states.select(element.state < 1000).max(element.state) + 1

    let s: integer
    let maxs: integer


    builder.StartTable()
        states.select(element.state < 1000).forAll(
            builder.StartObject()
                builder.PushKey("state").PushInteger(element.state)
                builder.PushKey("name").PushString(element.name)
            builder.EndObject()
        )

        builder.StartObject()
            builder.PushKey("state").PushInteger(newState)
            builder.PushKey("name").PushString('Nowa')
        builder.EndObject()

        states.select(element.state >= 1000).forAll(
            builder.StartObject()
                builder.PushKey("state").PushInteger(element.state)
                builder.PushKey("name").PushString(element.name)
            builder.EndObject()
        )

    builder.EndTable()

    result = builder
