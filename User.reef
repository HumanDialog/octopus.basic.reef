const MIN_USER_TASK_ORDER   = &h80000000
const LAST_USER_TASK_ORDER  = &h7FFFFFFF
--const LAST_USER_TASK_ORDER_STEP = 16    --2^4

class User
    login:                  string
	groupid:                integer
    Name:                   string
    Email:                  string
    Bio:                    string
    Avatar:                 string
    MyTasks(0..n):          Task                <backNav: Actor(0..1)>
    MyLists(0..n):          TaskList            <backNav: User>
    Groups(0..n):           UserGroup           <backNav: User>
    Folders(0..n):          Folder              <backNav: User>
    AllFolders(0..n):       Folder              <backNav: Owner>
    PinnedFolders:          Folder
    BasketFolder:           Folder
    SharedFolders:          Folder
    MessageChannels[0..n]:  MessageChannelUser      <backNav: User>
    AllMessageChannels[0..n]:  MessageChannelUser   <backNav: Owner>
    CreatedNotes(0..n):     Note                <backNav: CreatedBy>
    ModifiedNotes(0..n):    Note                <backNav: ModifiedBy>
    MyMessages(0..n):       Message
    CreatedTasks(0..n):     Task                <backNav: CreatedBy>
    UploadedFiles(0..n):    UploadedFile        <backNav: CreatedBy>
    Clipboards<0..n>:       Clipboard           <backNav: User>
    SubscribedLists[0..n]:  UserTaskList        <backNav: User>

    ArchivedLists:          TaskList
    HiddenLists:            TaskList
    DeletedLists:           TaskList
    ArchiveFolder:          Folder
    TrashFolder:            Folder
end class

constraint User::MyLists
    element.UserId = self.Id and element.Status = STATUS_ACTIVE

constraint User::ArchivedLists
    element.UserId = self.Id and element.Status = STATUS_ARCHIVED

constraint User::DeletedLists
    element.UserId = self.Id and element.Status = STATUS_DELETED

constraint User::HiddenLists
    element.UserId = self.Id and element.Status = STATUS_HIDDEN


constraint User::PinnedFolders
    element.UserId = self.Id and element.Status = FS_PINNED_ROOT_FOLDER

constraint User::SharedFolders
    element.UserId = self.Id and element.Status = FS_USER_ROOT_SHARED_FOLDER

constraint User::BasketFolder
    element.UserId = self.Id and element.Status = FS_BASKET_ROOT_FOLDER

constraint User::ArchiveFolder
    element.UserId = self.Id and element.Status = FS_USER_ARCHIVE_ROOT_FOLDER

constraint User::TrashFolder
    element.UserId = self.Id and element.Status = FS_USER_TRASH_ROOT_FOLDER



constraint User::MyTasks
    element.ActorId = self.Id and element.Status = STATUS_ACTIVE

constraint User::Folders
    element.UserId = self.Id and element.Status = FS_USER_ROOT_FOLDER

constraint User::AllFolders
    element.UserId = self.Id

constraint User::MessageChannels
    element.UserId = self.Id and element.Status = MCU_DIRECT

constraint User::AllMessageChannels
    element.UserId = self.Id

context User::GetBasketFolder: Folder
post:

    if self.BasketFolder.isNull then
        self.BasketFolder = self.AllFolders.newElement(e | e.Title = "__; en: Clipboard; es: Portapapeles; pl: Schowek" and e.Status = FS_BASKET_ROOT_FOLDER and e.Kind = FK_BASKET)
    end if

    result = self.BasketFolder

context User::GetPinnedFolders: Folder
post:

    if self.PinnedFolders.isNull then
        self.PinnedFolders = self.AllFolders.newElement(e | e.Title = self.Name + " Pinned Folders" and e.Status = FS_PINNED_ROOT_FOLDER)
    end if

    result = self.PinnedFolders

context User::GetSharedFolders: Folder
post:
    if self.SharedFolders.isNull then
        self.SharedFolders = self.AllFolders.newElement(element.Title = self.Name + " Shared Folders" and element.Status = FS_GROUP_ROOT_SHARED_FOLDER)
    end if
    result = self.SharedFolders


context User::FinishTasks()
post:
    self.MyTasks.select(element.State <> STATE_FINISHED).forAll(element.Finish())


--context User::MoveFolderToBasket(folder: Folder): FolderFolder
--pre:
--    self.Folders.exists(element.Id = folder.Id)
--post:
--    folder.User = null      -- removing from Folders collection
--    result = folder.CopyToBasket()


admin
context User::FindDirectMessageChannel(toWhom: User): MessageChannel
post:
    result = self.MessageChannels.select( e | e.MessageChannel.Users.count = 2 and e.MessageChannel.Users.exists(element.UserId = toWhom.Id)).first.MessageChannel

context User::cmc1(uid: integer): boolean
post:
    if self.MessageChannels.exists( e |
                e.MessageChannel.Users.count = 2
                and e.MessageChannel.Users.exists(element.UserId = toWhom.Id)) then
        result = true
    else
        result = false
    end if

context User::cmc(uid: integer): boolean
post:
    if self.MessageChannels.exists( e | e.MessageChannel.Users.exists(element.UserId = uid)) then
        result = true
    else
        result = false
    end if

context User::NewPrivateMessageChannel(title: string): MessageChannel
post:
    let order: integer = self.MessageChannels.max(element.Order)
    let umc: MessageChannelUser = self.MessageChannels.newElement(element.Order = order + ORDER_STEP)
    umc.MessageChannel = new MessageChannel
    umc.MessageChannel.Title = title
    result = umc.MessageChannel

admin
context User::AttachToChannel(channel: MessageChannel)
post:
    let order: integer = self.MessageChannels.max(element.Order)
    let umc: MessageChannelUser = self.MessageChannels.newElement(element.MessageChannel = channel
                and element.Order = order + ORDER_STEP)


context User::AddDirectMesssageChannel(toWhom: User): MessageChannel
pre:
    toWhom <> null
post:
    let channel: MessageChannel = self.FindDirectMessageChannel(toWhom)

    if channel = 0 then
        channel = self.NewPrivateMessageChannel(self.Name + ", " + toWhom.Name)
        toWhom.AttachToChannel(channel)
    end if


    result = channel


context User::AddWorkingPost(): Note
post:
    result = self.CreatedNotes.newElement(element.Kind = NK_POST)

context User::href: string
post:
    result = '/profile/' + self.Id


context User::GetSubscribedChannelsKickLabels: JsonObject
post:
    result = []
    --self.MessageChannels.forAll(ch |
    --    result = [..., ch.MessageChannel.KickLabel])

    self.AllMessageChannels.forAll(ch |
        result = [..., ch.MessageChannel.KickLabel])

context User::GetUnreadMessagesNo: integer
post:
    result = self.AllMessageChannels.sum(element.UnreadMessagesNo)

context User::CreateMyTask(Title: string, optional Summary: string = "", optional UserOrder: integer = 0): Task
post:
    if UserOrder = 0 then
        UserOrder = self.MyTasks.max(element.UserOrder) + ORDER_STEP
    end if

    result = self.CreatedTasks.newElement(t |
        t.Title = Title
        t.Summary = Summary
        t.UserOrder = UserOrder
        t.Actor = self)

context User::ValidateSubTreeCanonicalPaths()
post:
    self.Folders.forAll(element.ValidateSubTreeCanonicalPaths())
    self.SharedFolders.ValidateSubTreeCanonicalPaths()

    self.MyTasks.forAll(task: Task |
        if not task.InFolders.exists(element.IsCanonical) then
            if task.TaskList = null then
                task.ValidateSubTreeCanonicalPaths()
            end if
        end if
    )

    self.MyLists.forAll(element.ValidateSubTreeCanonicalPaths())

context User::Clipboard: Clipboard
post:
    result = self.Clipboards.first
    if result = null then
        result = self.Clipboards.newElement(
            element.Title = "__; en: Clipboard ("+ self.Name +"); es: Portapapeles ("+ self.Name +"); pl: Schowek ("+ self.Name +")"
        )
    end if

context User::CreateList(name: string, optional order: integer = 0, optional summary: string = ''): TaskList
post:
    let list: TaskList = self.MyLists.newElement
    list.Kind = TLK_KANBAN_CHECKLIST
    list.TaskStates = group.GetChecklistDefaultColumns().ToString()
    list.Name = name
    list.Order = order
    list.Summary = summary

    result = list

context User::CreateFolder(title: string, optional order: integer=0, optional summary: string = ""): Folder
post:
    if order = 0 then
        order = self.Folders.max(element.Order) + ORDER_STEP
    end if
    result = self.Folders.newElement(element.Title = title and element.Order=order and element.Summary = summary)
    result.ValidateSubTreeCanonicalPaths()

context User::ModifiedNotesCount: integer
post:
    result = self.ModifiedNotes.count

context User::AssignedTasksCount: integer
post:
    result = self.MyTasks.count