

const FS_PUBLIC_ROOT_FOLDER         = 15
const FS_PUBLIC_FOLDER              = 16
const FS_USER_ROOT_FOLDER           = 101
const FS_GROUP_ROOT_FOLDER          = 102
const FS_PINNED_ROOT_FOLDER         = 103
const FS_BASKET_ROOT_FOLDER         = 104
const FS_USER_FOLDER                = 111
const FS_GROUP_FOLDER               = 112
const FS_USER_ROOT_SHARED_FOLDER    = 131
const FS_GROUP_ROOT_SHARED_FOLDER   = 132
const FS_USER_SHARED_FOLDER         = 141
const FS_GROUP_SHARED_FOLDER        = 142
const FS_LATEST_ELEMENTS    = 1001

const FSX_IN_CALCULATION    = 100000

const FK_FOLDER             = 0
const FK_BASKET             = 1
const FK_DISCUSSION         = 2
const FK_TABLE              = 3
const FK_DOCUMENT           = 4

const FIN_PUBLIC_FOLDER     =  10000
const FIN_GROUP_FOLDER     =    9000

const FIN_PUBLIC     =  10000
const FIN_GROUP      =   9000
const FIN_USER       =   5000

-- [F]older [L]ink [I]nfo
const FLI_CANONICAL     = &h00000001

class Folder
    Title(128):         string
    Summary(196):       string
    Group:              Group       <backNav: AllFolders>
    User:               User        <backNav: Folders>
    Owner:              User        <backNav: AllFolders>
    Kind:               integer
    Status:             integer
    CanonicalPath(0):   string
    Folders[0..n]:      FolderFolder
    InFolders[0..n]:    FolderFolder
    Notes[0..n]:        FolderNote
    Tasks[0..n]:        FolderTask
    Files[0..n]:        FolderFile
    Order:              integer
    GroupId:            integer
    UserId:             integer
    FoldersCount:       integer
    NotesCount:         integer
    TasksCount:         integer
    CreationDate:	    date
    ModificationDate:   date
    CreatedBy:          User
end class


class FolderFolder
protected:
    Title(128):         string
public:
    Kind:               integer
    Order:              integer
    Pos(8):             string
    LinkInfo:           integer
    Group:              Group       <backNav: FolderFolder>
    User:               User        <backNav: FolderFolder>
    Folder(0..1):       Folder      <backNav: InFolders[0..n]>
    InFolder(0..1):     Folder      <backNav: Folders[0..n]>
    GroupId:            integer
    UserId:             integer
    InFolderId:         integer
    FolderId:           integer
end class

class FolderNote
    Title(128):     string
    Order:          integer
    Pos(8):         string
    LinkInfo:       integer
    Folder(0..1):   Folder  <backNav: Notes[0..n]>
    Note(0..1):     Note    <backNav: InFolders[0..n]>
    Role:           integer
end class


class FolderTask
    Title(128):     string
    Order:          integer
    Pos(8):         string
    LinkInfo:       integer
    Folder(0..1):   Folder <backNav: Tasks[0..n]>
    Task(0..1):     Task   <backNav: InFolders[0..n]>
end class


constraint Folder::Folders
    element.InFolderId = self.Id

constraint FolderFolder::Folder
    self.FolderId = element.Id

constraint FolderFolder::Group
    self.GroupId = element.Id

constraint FolderFolder::User
    self.UserId = element.Id


--context FolderFolder
--inv:
--    self.User = self.InFolder.User
--inv:
--    self.Group = self.InFolder.Group



---------------------------------------------------------------------------------
context Folder
inv:
    self.FoldersCount = self.Folders.count

context Folder
inv:
    self.NotesCount = self.Notes.count

context Folder
inv:
    self.TasksCount = self.Tasks.count

---------------------------------------------------------------------------------

context Folder::OnAfterCreate
post:
    self.CreationDate.SetUTCDate()
    self.CreatedBy = user

    self.ModificationDate = self.CreationDate


context Folder::href: string
post:
    select case self.Kind
        case FK_FOLDER
            result = '/folder/' + self.Id
        case FK_BASKET
            result = '/folder/' + self.Id
        case FK_DISCUSSION
            result = '/folder/' + self.Id
        case else
            result = '/folder/' + self.Id
    end select


context Folder::icon: string
post:
    select case self.Kind
        case FK_FOLDER
            result = 'folder'
        case FK_BASKET
            result = 'clipboard-pen-line'
        case FK_DISCUSSION
            result = 'messages-square'
        case else
            result = 'folder'
    end select


--STATUS-------------------------------------------------------------------------------



context Folder::GetAccLevel: integer
post:
    let status: integer = self.Status in
    if status >  FSX_IN_CALCULATION then
        status = status - FSX_IN_CALCULATION
    end if
    select case status
    case FS_USER_ROOT_FOLDER
        result = FIN_USER
    case FS_USER_FOLDER
        result = FIN_USER
    case FS_GROUP_ROOT_FOLDER
        result = FIN_GROUP
    case FS_GROUP_FOLDER
        result = FIN_GROUP
    case FS_PUBLIC_FOLDER
        result = FIN_PUBLIC
    end select




context Folder::CalculateStatus: integer
post:
    let level: integer in

    if self.IsRoot then
        result = self.Status
    else
        let maxAccLevel: integer = self.InFolders.iterate(e; acclevel: integer |
            level = e.InFolder.GetAccLevel
            if level > acclevel then acclevel = level end if)

        select case maxAccLevel
        case FIN_PUBLIC
            result = FS_PUBLIC_FOLDER
        case FIN_GROUP
            result = FS_GROUP_FOLDER
        case FIN_USER
            result = FS_USER_FOLDER
        end select
    end if

context Folder::RecalculateStatus
post:
    self.Status = self.CalculateStatus
    if self.Group = 0 and self.Status = FS_GROUP_FOLDER then
        self.Group = group
    end if

context App::st(i: integer): string
post:
    select case i
    case 1,2,3,4
        result = "Malo"
    case 5,6
        result = "Sporo"
    case else
        result = "Dużo"
    end select

context Folder::RecalculateStatusRec
post:
    select case self.Status
    case FS_USER_ROOT_FOLDER, FS_GROUP_ROOT_FOLDER, FS_PINNED_ROOT_FOLDER, FS_USER_ROOT_SHARED_FOLDER, FS_GROUP_ROOT_SHARED_FOLDER, FS_PUBLIC_ROOT_FOLDER
        --self.Status = self.Status + FSX_IN_CALCULATION 'Forbidden - breaks constraints
        self.Folders.forAll(element.Folder.RecalculateStatusRec)
    case FS_PUBLIC_FOLDER,FS_USER_FOLDER, FS_USER_SHARED_FOLDER, FS_GROUP_SHARED_FOLDER
        self.Status = self.CalculateStatus + FSX_IN_CALCULATION
        self.Folders.forAll(element.Folder.RecalculateStatusRec)
    end select

context Folder::CommitStatusRec
post:
    if self.Status > FSX_IN_CALCULATION then
        self.Status = self.Status - FSX_IN_CALCULATION
        self.Folders.forAll(element.Folder.CommitStatusRec)
    end if

context Folder::IsGroupFolder: boolean
post:
    result = (self.Status = FS_GROUP_FOLDER or self.Status = FS_GROUP_ROOT_FOLDER)

context Folder::IsPersonal: boolean
post:
    result = (self.Status = FS_USER_FOLDER or self.Status = FS_USER_ROOT_FOLDER)

context Folder::IsPublic: boolean
post:
     result = (self.Status = FS_PUBLIC_FOLDER or self.Status = FS_PUBLIC_ROOT_FOLDER)


context Folder::IsSharedGroupFolder: boolean
post:
     result = (self.Status = FS_GROUP_SHARED_FOLDER)

context Folder::IsSharedUserFolder: boolean
post:
     result = (self.Status = FS_USER_SHARED_FOLDER)

context Folder::IsRoot: boolean
post:
    select case self.Status
        case FS_USER_ROOT_FOLDER
            result = true
        case FS_USER_ROOT_SHARED_FOLDER
            result = true
        case FS_GROUP_ROOT_FOLDER
            result = true
        case FS_GROUP_SHARED_FOLDER
            result = true
        case FS_PINNED_ROOT_FOLDER
            result = true
        case FS_BASKET_ROOT_FOLDER
            result = true
        case else
            result = false
    end select


------------------------------------------------------------------------------------

context Folder::IsRootPinned: boolean
post:
    result = (self.Status = FS_PINNED_ROOT_FOLDER)

context Folder::IsPinned: boolean
post:
    result = user.PinnedFolders.Folders.exists(element.Folder.Id = self.Id)


context Folder::IsBasket: boolean
post:
    if user.BasketFolder.Id = self.Id then
        result = true
    else
        result = false
    end if




context Folder::CreateSubFolderExX(properties: JsonObject) : FolderFolder
post:
    result = self.CreateSubFolder(properties.Title, properties.Summary, properties.Order)


context Folder::CreateSubFolder(title: string, optional summary: string = "", optional order: integer = 0, optional kind: integer = 0): FolderFolder
pre Only logged in users may Create subFolders:
    user <> 0
post:
    let subFolder: Folder = user.AllFolders.newElement(subFolder |
                subFolder.Title = title
                subFolder.Summary = summary
                subFolder.Kind = kind
                subFolder.Group = group) in

    result = self.AttachFolderInt(subFolder, order)


context Folder::CreateSubForum(title: string, optional summary: string = "", optional order: integer = 0, optional kind: integer = 0): FolderFolder
post:
    result = self.CreateSubFolder(title, summary, order, FK_DISCUSSION)


context Folder::CreateNoteEx(properties: JsonObject) : FolderNote
pre Only logged in users may Create Notes:
    user <> 0
post:

    let n: Note = user.CreatedNotes.newElement(n |
            n.Title = properties.Title and
            n.Summary = properties.Summary) in

    result = self.Notes.newElement( e | e.Note = n and e.Order = properties.Order)
    n.RecalculateCanonicalLinksAfterAttach(result)


context Folder::CreateThread(title: string, optional summary: string = "", optional order: integer = 0): FolderNote
pre Only logged in users may Create Notes:
    user <> 0
post:
    let n: Note = user.CreatedNotes.newElement(n |
            n.Title = title and
            n.Summary = summary and
            n.Kind = NK_THREAD) in

    result = self.Notes.newElement( e | e.Note = n and e.Order = order)
    n.RecalculateCanonicalLinksAfterAttach(result)


context Folder::CreateTaskEx(properties: JsonObject) : FolderTask
pre Only logged in users may Create Tasks:
    user <> 0
post:
    let t: Task = user.CreatedTasks.newElement(t |
            t.Title = properties.Title
            t.Summary = properties.Summary) in

    result = self.Tasks.newElement( e | e.Task = t and e.Order = properties.Order)
    t.RecalculateCanonicalLinksAfterAttach(result)


context Folder::CreateFile(title: string, mimeType: string, size: integer, optional order: integer=0) : FolderFile
pre Only logged in users may upload files:
    user <> null
post:
    let upFile: UploadedFile
    let fileLink: FolderFile

    upFile = user.UploadedFiles.newElement(n |  n.Title = title
                                                n.MimeType = mimeType
                                                n.Size = size)

    if order = 0 then
        order = self.MaxOrder + ORDER_STEP
    end if

    fileLink = self.Files.newElement( e | e.File = upFile and e.Order = order)
    upFile.RecalculateCanonicalLinksAfterAttach(fileLink)
    result = fileLink


context Folder::DeletePermanently
post:
    -- what to do with content?
    --self.Folders
    --self.Notes
    --self.Tasks

    self.InFolders.removeAll    -- links leading to me
    self.delete

context Folder::DettachSubFolder(folderLink: FolderFolder)
pre:
    folderLink.InFolder.Id = self.Id
post:
    let folder: Folder = folderLink.Folder
    folderLink.delete
    folder.RecalculateStatus

context Folder::DeletePermanentlyFolder(folderLink: FolderFolder)
post:
    let folder: Folder = folderLink.Folder
    folder.DeletePermanently()

context Folder::MaxOrder: integer
post:
    let f: integer = self.Folders.max(element.Order)
    let n: integer = self.Notes.max(element.Order)
    let t: integer = self.Tasks.max(element.Order)
    let s: integer = self.Files.max(element.Order)

    result = f
    if n > result then
        result = n
    end if

    if t > result then
        result = t
    end if

    if s > result then
        result = s
    end if

context Folder::CopyToBasket(optional flags: integer=0): ElementReference
post:
    result = user.Clipboard.Push(self.Id, self.oclType, self.ref, self.Title, self.Summary, self.icon, self.href, flags)

-- to remove
context Folder::IsInBasket: boolean
post:
    result = false

context Folder::CopySubFolderToBasket(folderLink: FolderFolder, optional flags: integer=0): ElementReference
post:
    result = folderLink.Folder.CopyToBasket(flags)


context Folder::CutSubFolderToBasket(folderLink: FolderFolder): ElementReference
post:
    result = self.CopySubFolderToBasket(folderLink, EIF_CUT)
    self.DettachSubFolder(folderLink)


context Folder::CopyToBasketMulti(refs: JsonObject): JsonObject
post:
    let items: JsonObject
    items = []

    let refsNo :integer = refs.count
    let ref: string

    let itm: item
    let folderLink: FolderFolder
    let noteLink: FolderNote
    let taskLink: FolderTask
    let fileLink: FolderFile

    set(0 .. refsNo-1).forAll(i |
        ref = refs[i]
        itm = system.GetItemByRef(ref)
        select case itm.oclType
            case 'FolderFolder'
                folderLink = itm.asType("FolderFolder")
                items = [...,
                    {
                        id:         folderLink.FolderId,
                        typeName:   'Folder',
                        navPath:    folderLink.Folder.ref,
                        Title:      folderLink.Folder.Title,
                        Summary:    folderLink.Folder.Summary,
                        icon:       folderLink.Folder.icon,
                        href:       folderLink.Folder.href,
                        flags:      0
                    }]

            case 'FolderNote'
                noteLink = itm.asType("FolderNote")
                items = [...,
                    {
                        id:         noteLink.NoteId,
                        typeName:   'Note',
                        navPath:    noteLink.Note.ref,
                        Title:      noteLink.Note.Title,
                        Summary:    noteLink.Note.Summary,
                        icon:       noteLink.Note.icon,
                        href:       noteLink.Note.href,
                        flags:      0
                    }]

            case 'FolderTask'
                taskLink = itm.asType("FolderTask")
                items = [...,
                    {
                        id:         taskLink.TaskId,
                        typeName:   'Task',
                        navPath:    taskLink.Task.ref,
                        Title:      taskLink.Task.Title,
                        Summary:    taskLink.Task.Summary,
                        icon:       taskLink.Task.icon,
                        href:       taskLink.Task.href,
                        flags:      0
                    }]

            case 'FolderFile'
                fileLink = itm.asType("FolderFile")
                items = [...,
                    {
                        id:         fileLink.FileId,
                        typeName:   'UploadedFile',
                        navPath:    fileLink.File.ref,
                        Title:      fileLink.File.Title,
                        Summary:    fileLink.File.Summary,
                        icon:       fileLink.File.icon,
                        href:       fileLink.File.href,
                        flags:      0
                    }]


        end select
    )

    result = user.Clipboard.PushMulti(items)


context Folder::CutToBasketMulti(refs: JsonObject): JsonObject
post:
    let items: JsonObject
    items = []

    let refsNo :integer = refs.count
    let ref: string

    let itm: item
    let folderLink: FolderFolder
    let noteLink: FolderNote
    let taskLink: FolderTask
    let fileLink: FolderFile

    set(0 .. refsNo-1).forAll(i |
        ref = refs[i]
        itm = system.GetItemByRef(ref)
        select case itm.oclType
            case 'FolderFolder'
                folderLink = itm.asType("FolderFolder")
                items = [...,
                    {
                        id:         folderLink.FolderId,
                        typeName:   'Folder',
                        navPath:    folderLink.Folder.ref,
                        Title:      folderLink.Folder.Title,
                        Summary:    folderLink.Folder.Summary,
                        icon:       folderLink.Folder.icon,
                        href:       folderLink.Folder.href,
                        flags:      EIF_CUT
                    }]
                self.DettachSubFolder(folderLink)

            case 'FolderNote'
                noteLink = itm.asType("FolderNote")
                items = [...,
                    {
                        id:         noteLink.NoteId,
                        typeName:   'Note',
                        navPath:    noteLink.Note.ref,
                        Title:      noteLink.Note.Title,
                        Summary:    noteLink.Note.Summary,
                        icon:       noteLink.Note.icon,
                        href:       noteLink.Note.href,
                        flags:      EIF_CUT
                    }]
                self.DettachNote(noteLink)

            case 'FolderTask'
                taskLink = itm.asType("FolderTask")
                items = [...,
                    {
                        id:         taskLink.TaskId,
                        typeName:   'Task',
                        navPath:    taskLink.Task.ref,
                        Title:      taskLink.Task.Title,
                        Summary:    taskLink.Task.Summary,
                        icon:       taskLink.Task.icon,
                        href:       taskLink.Task.href,
                        flags:      EIF_CUT
                    }]
                self.DettachTask(taskLink)

            case 'FolderFile'
                fileLink = itm.asType("FolderFile")
                items = [...,
                    {
                        id:         fileLink.FileId,
                        typeName:   'UploadedFile',
                        navPath:    fileLink.File.ref,
                        Title:      fileLink.File.Title,
                        Summary:    fileLink.File.Summary,
                        icon:       fileLink.File.icon,
                        href:       fileLink.File.href,
                        flags:      EIF_CUT
                    }]
                self.DettachFile(fileLink)


        end select
    )

    result = user.Clipboard.PushMulti(items)



context Folder::DettachAllContent
post:
    self.Folders.removeAll
    self.Notes.removeAll
    self.Tasks.removeAll
    self.Files.removeAll


context Folder::AttachFolder(folder: Folder, optional order: integer = 0) : boolean
post:
    if not self.Folders.exists(element.Folder.Id = folder.Id) then
        if order = 0 then
            order = self.MaxOrder + ORDER_STEP
        end if
        self.AttachFolderInt(folder, order)
        result = true
    else
        result = false
    end if

context Folder::AttachFolderInt(subFolder: Folder, order: integer): FolderFolder
post:
    let link: FolderFolder = self.Folders.newElement(ff | ff.Folder = subFolder and ff.Order = order)

    subFolder.RecalculateStatus()
    subFolder.RecalculateCanonicalLinksAfterAttach(link)

    result = link


context Folder::AttachNote(note: Note, optional order: integer = 0) : boolean
post:
    let folderNote: FolderNote

    if not self.Notes.exists(element.Note.Id = note.Id) then
        if order = 0 then
            order = self.MaxOrder + ORDER_STEP
        end if

        folderNote = self.Notes.newElement(e | e.Note=note and e.Order=order)
        note.RecalculateCanonicalLinksAfterAttach(folderNote)
        result = true
    else
        result = false
    end if

context Folder::AttachTask(task: Task, optional order: integer = 0) : boolean
post:
    let folderTask: FolderTask
    if not self.Tasks.exists(element.Task.Id = task.Id) then
        if order = 0 then
            order = self.MaxOrder + ORDER_STEP
        end if

        folderTask = self.Tasks.newElement(e | e.Task=task and e.Order=order)
        task.RecalculateCanonicalLinksAfterAttach(folderTask)
        result = true
    else
        result = false
    end if

context Folder::AttachFile(upFile: UploadedFile, optional order: integer = 0) : boolean
post:
    let folderFile: FolderFile

    if not self.Files.exists(element.File.Id = upFile.Id) then
        if order = 0 then
            order = self.MaxOrder + ORDER_STEP
        end if

        folderFile = self.Files.newElement(e | e.File=upFile and e.Order=order)
        upFile.RecalculateCanonicalLinksAfterAttach(folderFile)
        result = true
    else
        result = false
    end if


context Folder::AttachClipboard(references: JsonObject): Folder
post:
    let referencesNo: integer = references.count
    let order: integer = self.MaxOrder + ORDER_STEP

    let reference: JsonObject
    let id: integer
    let typeName: string
    let flags: integer

    let folder: Folder
    let note: Note
    let task: Task
    let upFile: UploadedFile

    set(0 .. referencesNo-1).forAll(i |
        reference = references[i]
        id = reference.id
        typeName = reference.typeName
        flags = reference.flags         -- todo: EIF_CUT handle

        select case typeName
            case 'Folder'
                folder = system.GetItem(id, typeName)
                if folder <> null then
                    if self.AttachFolder(folder, order) then
                        order = order + ORDER_STEP
                    end if
                end if
            case 'Note'
                note = system.GetItem(id, typeName)
                if note <> null then
                    if self.AttachNote(note, order) then
                        order = order + ORDER_STEP
                    end if
                end if

            case 'Task'
                task = system.GetItem(id, typeName)
                if task <> null then
                    if self.AttachTask(task, order) then
                        order = order + ORDER_STEP
                    end if
                end if

            case 'UploadedFile'
                upFile = system.GetItem(id, typeName)
                if upFile <> null then
                    if self.AttachFile(upFile, order) then
                        order = order + ORDER_STEP
                    end if
                end if

        end select
    )
    result = self


context Folder::DettachElementMulti(items: JsonObject): Folder
post:
    let typeName: string
    let itemId: integer

    let t: FolderTask
    let n: FolderNote
    let f: FolderFolder
    let s: FolderFile

    let itemsNo: integer = items.count
    set(0 .. itemsNo-1).forAll(i |
        typeName = items[i].Type
        itemId = items[i].Id

        select case typeName
            case 'FolderFolder'
                f = system.GetItem(itemId, typeName)
                self.DettachSubFolder(f)

            case 'FolderNote'
                n = system.GetItem(itemId, typeName)
                self.DettachNote(n)

            case 'FolderTask'
                t = system.GetItem(itemId, typeName)
                self.DettachTask(t)

            case 'FolderFile'
                s = system.GetItem(itemId, typeName)
                self.DettachFile(s)
        end select
    )

context Folder::DettachNote(noteLink: FolderNote)
pre:
    noteLink.Folder.Id = self.Id
post:
    noteLink.delete

context Folder::DeletePermanentlyNote(noteLink: FolderNote)
post:
    let note: Note = noteLink.Note
    note.DeletePermanently()


context Folder::CopyNoteToBasket(noteLink: FolderNote, optional flags: integer=0): ElementReference
post:
    result = noteLink.Note.CopyToBasket(flags)


context Folder::CutNoteToBasket(noteLink: FolderNote): ElementReference
post:
    result = self.CopyNoteToBasket(noteLink, EIF_CUT)
    self.DettachNote(noteLink)


context Folder::DettachTask(taskLink: FolderTask)
pre:
    taskLink.Folder.Id = self.Id
post:
    taskLink.delete    -- Will the task be automatically deleted if this was the only reference to it?


context Folder::DeletePermanentlyTask(taskLink: FolderTask)
post:
    let task: Task = taskLink.Task
    task.DeletePermanently()


context Folder::CopyTaskToBasket(taskLink: FolderTask, optional flags: integer=0): ElementReference
post:
    result = taskLink.Task.CopyToBasket(flags)


context Folder::CutTaskToBasket(taskLink: FolderTask): ElementReference
post:
    result = self.CopyTaskToBasket(taskLink, EIF_CUT)
    self.DettachTask(taskLink)


context Folder::DettachFile(fileLink: FolderFile)
pre:
    fileLink.Folder.Id = self.Id
post:
    fileLink.delete

context Folder::DeletePermanentlyFile(fileLink: FolderFile)
post:
    let upFile: UploadedFile = fileLink.File
    upFile.DeletePermanently()


context Folder::CopyFileToBasket(fileLink: FolderFile, optional flags: integer=0): ElementReference
post:
    result = fileLink.File.CopyToBasket(flags)


context Folder::CutFileToBasket(fileLink: FolderFile): ElementReference
post:
    result = self.CopyFileToBasket(fileLink, EIF_CUT)
    self.DettachFile(fileLink)



context Folder::TogglePinned : FolderFolder
post:
    let pinnedLink :FolderFolder = user.PinnedFolders.Folders.select(element.Folder.Id = self.Id).first
    if pinnedLink <> null then
        pinnedLink.delete
        result = null
    else
        let maxOrder :integer = user.PinnedFolders.Folders.max(element.Order)
        result = user.PinnedFolders.Folders.newElement(e | e.Folder = self and e.Order = maxOrder+ORDER_STEP)
    end if


context Folder::AddPost(title: string, summary: string, content: string, tags: string): Note
post:
    let note: Note = user.CreatedNotes.newElement
    result = self.AttachPost(note, title, summary, content, tags)

admin
context Folder::AttachPost(note: Note, title: string, summary: string, content: string, tags: string): Note
post:
    note.Kind = NK_THREAD
    note.Title = title
    --note.Summary = summary
    note.Content = content
    note.Tags = tags
    --note.Summary = note.Content.textFromHTML(128, true)

    let maxOrder: integer = self.MaxOrder
    let folderNote: FolderNote = self.Notes.newElement(e | e.Note = note and e.Order = maxOrder+ORDER_STEP)
    note.RecalculateCanonicalLinksAfterAttach(folderNote)
    --note.UpdateLatestGroupActivity()
    result = note


context Folder::DeletePermanentlyMulti(items: JsonObject): Folder
post:
    let typeName: string
    let itemId: integer

    let t: FolderTask
    let n: FolderNote
    let f: FolderFolder
    let s: FolderFile

    let itemsNo: integer = items.count
    set(0 .. itemsNo-1).forAll(i |
        typeName = items[i].Type
        itemId = items[i].Id

        select case typeName
            case 'FolderFolder'
                f = system.GetItem(itemId, typeName)
                self.DeletePermanentlyFolder(f)

            case 'FolderNote'
                n = system.GetItem(itemId, typeName)
                self.DeletePermanentlyNote(n)

            case 'FolderTask'
                t = system.GetItem(itemId, typeName)
                self.DeletePermanentlyTask(t)

            case 'FolderFile'
                s = system.GetItem(itemId, typeName)
                self.DeletePermanentlyFile(s)
        end select
    )


context Folder::CalculateCanonicalPath: string
post:
    let parentPath: JsonObject
    let canonicalPath: JsonObject

    let canonicalLink: FolderFolder
    let parentFolder: Folder

    select case self.Status
        case FS_PUBLIC_ROOT_FOLDER
            canonicalPath = [ ]

        case FS_GROUP_ROOT_FOLDER, FS_GROUP_ROOT_SHARED_FOLDER
            canonicalPath = [
                {
                    Name: '__; en: Common folders; es: Carpetas comunes; pl: Wspólne foldery',
                    href: '/group-folders'
                }
            ]


        case FS_USER_ROOT_FOLDER, FS_USER_ROOT_SHARED_FOLDER
            canonicalPath = [
                {
                    Name: '__; en: My Folders; es: Mis carpetas; pl: Moje foldery',
                    href: '/myfolders'
                }
            ]

        case else
            canonicalLink = self.InFolders.select(element.IsCanonical).first
            if canonicalLink <> null then
                parentFolder = canonicalLink.InFolder
                if not parentFolder.CanonicalPath.isEmpty then
                    parentPath = new JsonObject
                    parentPath.Parse(parentFolder.CanonicalPath)
                    if parentPath.count > 0 then
                        canonicalPath = [...parentPath]
                    else
                        canonicalPath = []
                    end if

                    canonicalPath = [...,
                        {
                            Name: parentFolder.Title,
                            Summary: parentFolder.Summary,
                            href: parentFolder.href,
                            icon: parentFolder.icon
                        }
                    ]
                else
                    canonicalPath = []
                end if
            else
                canonicalPath = []
            end if
    end select

    result = canonicalPath.ToString()

context Folder::ValidateSubTreeCanonicalPaths
post:
    self.CanonicalPath = self.CalculateCanonicalPath()

    self.Folders.select(element.IsCanonical).forAll(link: FolderFolder |
        link.Folder.ValidateSubTreeCanonicalPaths()
    )

    self.Notes.select(element.IsCanonical).forAll(link: FolderNote |
        link.Note.ValidateSubTreeCanonicalPaths()
    )

    self.Tasks.select(element.IsCanonical).forAll(link: FolderTask |
        link.Task.ValidateSubTreeCanonicalPaths()
    )


context Folder::RecalculateCanonicalLinksAfterAttach(newLink: FolderFolder)
post:
    let changed: boolean = false
    let prevCanonicalLink: FolderFolder = self.InFolders.select(element.IsCanonical).first

    let fromFolder: Folder = prevCanonicalLink.InFolder
    let toFolder: Folder = newLink.InFolder

    if prevCanonicalLink = null then
        newLink.LinkInfo = newLink.LinkInfo | FLI_CANONICAL
        changed = true
    else

        if toFolder.IsPublic then
            if not fromFolder.IsPublic then
                newLink.LinkInfo = newLink.LinkInfo | FLI_CANONICAL
                prevCanonicalLink.LinkInfo = prevCanonicalLink.LinkInfo & (~FLI_CANONICAL)
                changed = true
            end if
        else
            if toFolder.IsGroupFolder then
                if fromFolder.IsPersonal then
                    newLink.LinkInfo = newLink.LinkInfo | FLI_CANONICAL
                    prevCanonicalLink.LinkInfo = prevCanonicalLink.LinkInfo & (~FLI_CANONICAL)
                    changed = true
                end if
            end if
        end if

    end if

    if changed = true then
        self.ValidateSubTreeCanonicalPaths()
    end if


context Folder::GetCanonicalPath: JsonObject
post:
    if not self.CanonicalPath.isEmpty then
        result = new JsonObject
        result.Parse(self.CanonicalPath)
    else
        result = new JsonObject
        result = []
    end if


context Folder::AttachMeTo(references: JsonObject)
post:
    let referencesNo: integer = references.count

    let reference: JsonObject
    let id: integer
    let typeName: string
    let flags: integer = 0

    let folder: Folder
    let grp: Group
    let usr: User

    set(0 .. referencesNo-1).forAll(i |
        reference = references[i]
        id = reference.id
        typeName = reference.typeName
        flags = reference.flags

        select case typeName
            case 'Folder'
                folder = system.GetItem(id, typeName)
                if folder <> null then
                    folder.AttachFolder(self)
                end if

            case 'Group'
                grp = system.GetItem(id, typeName)
                if grp <> null then
                    grp.Folders.insert(self)
                end if

            case 'User'
                usr = system.GetItem(id, typeName)
                if usr <> null then
                    usr.Folders.insert(self)
                end if


        end select
    )


context Folder::ChangeKind(kind: integer): Folder
post:
    self.Kind = kind
    result = self

-- ==============================================================================


context FolderFolder
inv:
    self.Title = self.Folder.Title

context FolderFolder::GetTitle(): string
post:
    result = self.Title

context FolderFolder::SetTitle(value: string)
post:
    self.Folder.Title = value
    self.Folder.ValidateSubTreeCanonicalPaths()


context FolderFolder::Summary: string
post:
    result = self.Folder.Summary

context FolderFolder::SetSummary(value: string)
post:
    self.Folder.Summary = value




context FolderFolder::href: string
post:
    result = self.Folder.href

context FolderFolder::icon: string
post:
    result = self.Folder.icon


context FolderFolder::IsPinned: boolean
post:
    result = self.Folder.IsPinned

context FolderFolder::IsInBasket: boolean
post:
    result = self.Folder.IsInBasket



context FolderFolder::GetLastForumActivity(): JsonObject
pre:
    self.Folder.Kind = FK_DISCUSSION
post:
    let topThread: FolderNote in
    let lastUserName: string

    topThread = self.Folder.Notes.orderedBy("Order").last
    if topThread <> null then

        if topThread.ModifiedBy <> null then
            lastUserName = topThread.ModifiedBy.Name
        end if

        result = {
            title: topThread.Title,
            lastActivity: topThread.ModificationDate,
            lastUser: lastUserName
        }

    else
        result = null
    end if


context FolderFolder::IsCanonical: boolean
post:
    result = (self.LinkInfo & FLI_CANONICAL) <> 0


context FolderFolder::SetLocationAsCanonical
post:
    self.Folder.InFolders.select(element.IsCanonical).forAll(element.LinkInfo = element.LinkInfo & (~FLI_CANONICAL))
    self.LinkInfo = self.LinkInfo | FLI_CANONICAL
    self.Folder.ValidateSubTreeCanonicalPaths()

context FolderFolder::AttachMeTo(references: JsonObject)
post:
    self.Folder.AttachMeTo(references)


context FolderFolder::MoveMeTo(references: JsonObject)
post:
    self.InFolder = null
    self.Folder.AttachMeTo(references)
    self.delete


context FolderFolder::InTitle: string
post:
    result = self.InFolder.Title

context FolderFolder::InSummary: string
post:
    result = self.InFolder.Summary

context FolderFolder::InHRef: string
post:
    result = self.InFolder.href

context FolderFolder::InIcon: string
post:
    result = self.InFolder.icon

-- ==============================================================================


context FolderNote
inv:
    self.Title = self.Note.Title


context FolderNote::SetTitle(value: string)
post:
    self.Note.Title = value


context FolderNote::Summary: string
post:
    result = self.Note.Summary


context FolderNote::SetSummary(value: string)
post:
    self.Note.Summary = value


context FolderNote::href: string
post:
    result = self.Note.href

context FolderNote::icon: string
post:
    result = self.Note.icon

context FolderNote::ModifiedBy: User
post:
    result = self.Note.ModifiedBy

context FolderNote::ModificationDate: date
post:
    result = self.Note.ModificationDate

context FolderNote::Tags: string
post:
    result = self.Note.Tags

context FolderNote::NotesCount: integer
post:
    result = self.Note.NotesCount

context FolderNote::IsPinned: boolean
post:
    result = self.Note.IsPinned

context FolderNote::IsInBasket: boolean
post:
    result = self.Note.IsInBasket

context FolderNote::IsCanonical: boolean
post:
    result = (self.LinkInfo & FLI_CANONICAL) <> 0


context FolderNote::SetLocationAsCanonical
post:
    self.Note.InFolders.select(element.IsCanonical).forAll(element.LinkInfo = element.LinkInfo & (~FLI_CANONICAL))
    self.Note.InNotes.select(element.IsCanonical).forAll(element.LinkInfo = element.LinkInfo & (~FLI_CANONICAL))
    self.Note.InTasks.select(element.IsCanonical).forAll(element.LinkInfo = element.LinkInfo & (~FLI_CANONICAL))

    self.LinkInfo = self.LinkInfo | FLI_CANONICAL
    self.Note.ValidateSubTreeCanonicalPaths()


context FolderNote::AttachMeTo(references: JsonObject)
post:
    self.Note.AttachMeTo(references)

context FolderNote::MoveMeTo(references: JsonObject)
post:
    self.Folder = null
    self.Note.AttachMeTo(references)
    self.delete

context FolderNote::InTitle: string
post:
    result = self.Folder.Title

context FolderNote::InSummary: string
post:
    result = self.Folder.Summary

context FolderNote::InHRef: string
post:
    result = self.Folder.href

context FolderNote::InIcon: string
post:
    result = self.Folder.icon

-- ==============================================================================


context FolderTask
inv:
    self.Title = self.Task.Title


context FolderTask::SetTitle(value: string)
post:
    self.Task.Title = value


context FolderTask::Summary: string
post:
    result = self.Task.Summary


context FolderTask::SetSummary(value: string)
post:
    self.Task.Summary = value


context FolderTask::href: string
post:
    result = self.Task.href

context FolderTask::icon: string
post:
    result = self.Task.icon

context FolderTask::ListName: string
post:
    result = self.Task.TaskList.Name

context FolderTask::State: string
post:
    result = self.Task.State

context FolderTask::IsPinned: boolean
post:
    result = self.Task.IsPinned

context FolderTask::SetDueDate(value: date)
post:
    self.Task.DueDate = value

context FolderTask::DueDate: date
post:
    result = self.Task.DueDate

context FolderTask::IsInBasket: boolean
post:
    result = self.Task.IsInBasket

context FolderTask::IsCanonical: boolean
post:
    result = (self.LinkInfo & FLI_CANONICAL) <> 0

context FolderTask::SetLocationAsCanonical
post:
    self.Task.InFolders.select(element.IsCanonical).forAll(element.LinkInfo = element.LinkInfo & (~FLI_CANONICAL))
    self.LinkInfo = self.LinkInfo | FLI_CANONICAL
    self.Task.ValidateSubTreeCanonicalPaths()


context FolderTask::AttachMeTo(references: JsonObject)
post:
    self.Task.AttachMeTo(references)

context FolderTask::MoveMeTo(references: JsonObject)
post:
    self.Folder = null
    self.Task.AttachMeTo(references)
    self.delete

context FolderTask::InTitle: string
post:
    result = self.Folder.Title

context FolderTask::InSummary: string
post:
    result = self.Folder.Summary

context FolderTask::InHRef: string
post:
    result = self.Folder.href

context FolderTask::InIcon: string
post:
    result = self.Folder.icon