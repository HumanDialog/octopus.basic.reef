class Group
--public:
    Members[0..n]:	            UserGroup       <backNav: Group>
    IsPublic:                   boolean

--public:
    Name:                       string

    Lists(0..n):                TaskList        <backNav: InGroup>
    AllLists(0..n):             TaskList        <backNav: Group>
    Folders(0..n):              Folder          <backNav: InGroup>
    AllFolders(0..n):           Folder          <backNav: Group>
    SharedFolders:              Folder
    MessageChannels(0..n):      MessageChannel  <backNav: InGroup>
    AllMessageChannels(0..n):   MessageChannel  <backNav: Group>
    AllTags:                    string
    ListIndexPrefix:            string
    ActiveProjects(0..n):       Project
    AllProjects(0..n):          Project

    RelatedGroups(0..n):        GroupGroup   <backNav: FromGroup>
    RelatedToGroups(0..n):      GroupGroup   <backNav: Group>
    FolderFolder[0..n]:         FolderFolder <backNav: Group>
    TaskIndexCounter:           integer
end class

class GroupGroup
    Group:                  Group
    FromGroup:              Group
end class

class UserGroup
    Group:                  Group           <backNav: Members[0..n]>
    User:                   User            <backNav: Groups(0..n)>
end class

context Group::Info: string
post:
    result = "" + self.Id + ": " + self.Name

context Group::OnAfterCreate
post:
    self.ListIndexPrefix = 'OCT'
    self.CreateList("Things to do")


-- framework callbak invoked when Group is created. 
-- variables 'user' and 'group' are  set. supervisor access rights.
context Group::InitGroup()
post:
    -- tasklists
    self.VerifyTaskLists()

    -- folders
    user.VerifyFolders()

    if self.Folders.first = 0 then
        self.NewFolder("Notes")
        self.NewFolder("Projects")
    end if

    -- messages
    if  self.MessageChannels.first = 0 then
      self.AddGeneralMessageChannel("Announcements")
      self.AddGeneralMessageChannel("General")
      self.AddGeneralMessageChannel("Random")
  end if


constraint Group::Lists
    element.GroupId = self.Id and element.Status = TLS_GROUP_ACTIVE_LIST


constraint Group::AllLists
    element.GroupId = self.Id


constraint Group::Folders
    element.GroupId = self.Id and element.Status = FS_GROUP_ROOT_FOLDER

constraint Group::SharedFolders
    element.GroupId = self.Id and element.Status = FS_GROUP_ROOT_SHARED_FOLDER

constraint Group::AllFolders
    element.GroupId = self.Id

constraint Group::MessageChannels
    element.GroupId = self.Id and element.Status = CS_GROUP_ROOT_CHANNEL


constraint Group::AllMessageChannels
    element.GroupId = self.Id


context Group::GetPredefinedTaskStates(): JsonObject
post:
    result = [
         {
            name: "__;en: Unspecified; es: Sin especificar; pl: Nieokreślone",
            state: STATE_UNSPECIFIED
        },
        {
            name: "__; en: In preparation: es: En preparación; pl: W przygotowaniu",
            state: STATE_IN_PREPARATION
        },
        {
            name: "__; en: Planned; es: Planificado; pl: Planowane",
            state: STATE_PLANNED
        },
        {
            name: "__; en: Ready; es: Listo; pl: Gotowe",
            state: STATE_READY
        },
        {
            name: "__; en: Executing; es: En ejecución; pl: W trakcie",
            state: STATE_EXECUTING
        },
        {
            name: "__; en: Finished; es: Finalizado; pl: Zakończone",
            state: STATE_FINISHED
        },
        {
            name: "__; en: Closed; es: Cerrado; pl: Zamknięte",
            state: STATE_CLOSED
        },
        {
            name: "__; en: Archived; es: Archivado; pl: Archiwizowane",
            state: STATE_ARCHIVED
        }
    ]


context Group::GetChecklistDefaultColumns(): JsonObject
post:
    let checkColumns :JsonObject = [
        {
            name: '__; en: To do; es: Por hacer; pl: Do zrobienia',
            state: STATE_UNSPECIFIED
        },
        {
            name: '__; en: Finished; es: Terminado; pl: Zakończone',
            state: STATE_FINISHED
        }
    ]
    result = checkColumns

context Group::CreateList(name: string, optional order: integer = 0): TaskList
post:
    let list: TaskList = self.Lists.newElement
    list.Kind = TLK_KANBAN_CHECKLIST
    list.TaskStates = self.GetChecklistDefaultColumns().ToString()
    list.Name = name
    list.Order = order

    result = list

context Group::GetTaskListTypes: JsonObject
post:
    -- simple predefined:
    let checkList: JsonObject = {
        Name: '__; en: List; es: Lista; pl: Lista',
        Summary: '__; en: Simple task list; es: Lista de tareas simple; pl: Prosta lista zadań',
        Kind: TLK_LIST,
        TaskStates: []
    }

    let simplaBoard: JsonObject = {
        Name: '__; en: Board; es: Tablero; pl: Tablica',
        Summary: '__; en: Simple kanban board; es: Tablero kanban simple; pl: Prosta tablica kanban',
        Kind: TLK_KANBAN_CHECKLIST,
        TaskStates: self.GetChecklistDefaultColumns()
    }

    -- process predefined lists:
    let sprintList: JsonObject = {
        Name: 'Sprint',
        Kind: TLK_KANBAN_PROCESS,
        TaskStates: [
            {
                name: "__; en: Preparing; es: Preparación; pl: W przygotowaniu",
                state: STATE_IN_PREPARATION
            },
            {
                name: "__; en: Ready; es: Listo; pl: Gotowe",
                state: STATE_PLANNED
            },
            {
                name: "__; en: Under work; es: En proceso; pl: W trakcie",
                state: STATE_EXECUTING
            },
            {
                name: "__; en: To check; es: Para comprobar; pl: Do sprawdzenia",
                state: 5000
            },
            {
                name: "__; en: Finished; es: Terminado; pl: Zakończone",
                state: STATE_FINISHED
            }
        ]
    }


    let ideasList: JsonObject = {
        Name: '__; en: Ideas; es: Ideas; pl: Pomysły',
        Kind: TLK_KANBAN_PROCESS,
        TaskStates: [
            {
                name: "__; en: Notes; es: Notas; pl: Notatki",
                state: STATE_IN_PREPARATION
            },
            {
                name: "__; en: Specifying; es: Especificar; pl: Specyfikowanie",
                state: STATE_EXECUTING
            },
            {
                name: "__; en: Knowledge; es: Conocimiento; pl: Wiedza",
                state: STATE_FINISHED
            }
        ]
    }

    result = [
        checkList,
        simplaBoard,
        sprintList,
        ideasList
    ]



    ------------ Messages -------------

context Group::AddGeneralMessageChannel(title: string, optional order: integer): MessageChannel
post:
    if order = 0 then
        order = self.MessageChannels.max(element.Order) + ORDER_STEP
    end if

    result = self.MessageChannels.newElement(element.Title = title and element.Order = order)

context Group::GetPossibleDirectChannelUsers(optional excludeExisting: boolean = false): JsonObject
post:
    result = []

    let canAdd: boolean = false
    self.Members.select(element.User <> user).forAll(ug |
        if excludeExisting then
            if user.FindDirectMessageChannel(ug.User) <> null then
                canAdd = false
            else
                canAdd = true
            end if
        else
            canAdd = true
        end if

        if canAdd then
            result = [..., {
                ref: './User/' + ug.UserId,
                Name: ug.User.Name
            }]
        end if
    )


context Group::GetLatestDiscussionsFolder(): Folder
post:
    result = self.AllFolders.select(element.Status = FS_LATEST_ELEMENTS and element.Kind = FK_DISCUSSION).first
    if result = null then
        result = self.AllFolders.newElement(element.Status = FS_LATEST_ELEMENTS and element.Kind = FK_DISCUSSION)
    end if