-- Genaral status of Tasks, TaskLists and Projects
const STATUS_ACTIVE = 0     -- This is a data we usually work on
const STATUS_ARCHIVED = 1

const STATE_UNSPECIFIED       = 0     -- [000-999]
const STATE_IN_PREPARATION    = 1000  -- [1000-1999]
const STATE_PLANNED           = 2000  -- [2000-2999]
const STATE_READY             = 3000  -- [3000-3999]
const STATE_EXECUTING         = 4000  -- [4000 - 6999]
const STATE_FINISHED          = 7000  -- [7000 - 7999]
const STATE_CLOSED            = 8000  -- [8000 - 8999]
const STATE_ARCHIVED          = 9000  -- [9000 - 9999]

--?enum state = [draft: 0, prepared: 1, accepted: 100, started: 101]
const ORDER_STEP        = 64


class Task
protected:
    Title(128):             string
public:    
    Summary(196):	        string
    Tags(64):               string
    Index(16):              string
    Kind:                   integer
    State:                  integer
    CreatedBy:              User <backNav: CreatedTasks>
    Actor:                  User
    DueDate:		        date
    Effort:                 integer
    Status:                 integer

    Steps[0..n]:	        TaskStep
    Description:	        string
    Images:                 string      <readOnly>
    AttachedFiles:          string      <readOnly>
    CanonicalPath(0):       string

    TaskList(0..1):         TaskList    <backNav: AllTasks>
    InFolders[0..n]:        FolderTask
    Notes[0..n]:            TaskNote
    Files[0..n]:            TaskFile
    InMessages[0..n]:       MessageTask
    ListOrder:              integer
    UserOrder:              integer

    TaskListId:             integer
    ActorId:                integer
    CreatedById:            integer
end class


class TaskStep
    Label:                  string
    Done:                   boolean
    Order:                  integer
end class

class TaskNote
    Note:                   Note <backNav: InTasks>
    Task:                   Task <backNav: Notes>
    LinkInfo:               integer
end class


constraint Task::TaskList
    self.TaskListId = element.Id


context Task::Finish()
post:
    self.ChangeTaskState(STATE_FINISHED)


context Task::Archive()
post:
    self.Status = STATUS_ARCHIVED

context Task::MainPage: string
post:
    result = "TaskDoc/"+self.Id

context Task::href: string
post:
    result = '/task/' + self.Id


context Task::DeletePermanently
post:
    self.InFolders.removeAll
    self.InMessages.removeAll
    self.Notes.removeAll
    self.Files.removeAll
    self.delete


context Task::SetTitle(val: string)
post:
    self.Title = val
    self.ValidateSubTreeCanonicalPaths()


context Task::GetTitle(): string
post:
    result = self.Title

context Task::ChangeTaskState(newState: integer)
post:
    if self.State <> newState then
        self.State = newState
    end if

context Task::ReduceStateToBase()
post:
    let newState: integer = -1
    if self.State < STATE_UNSPECIFIED then
        newState = STATE_UNSPECIFIED
    else if self.State > STATE_UNSPECIFIED and self.State < STATE_IN_PREPARATION then
        newState = STATE_UNSPECIFIED
    else if self.State > STATE_IN_PREPARATION and self.State < STATE_PLANNED then
        newState = STATE_IN_PREPARATION
    else if self.State > STATE_PLANNED and self.State < STATE_READY then
        newState = STATE_PLANNED
    else if self.State > STATE_READY and self.State < STATE_EXECUTING then
        newState = STATE_READY
    else if self.State > STATE_EXECUTING and self.State < STATE_FINISHED then
        newState = STATE_EXECUTING
    else if self.State > STATE_FINISHED and self.State < STATE_CLOSED then
        newState = STATE_FINISHED
    else if self.State > STATE_CLOSED and self.State < STATE_ARCHIVED then
        newState = STATE_ARCHIVED
    else if self.State > STATE_ARCHIVED then
        newState = STATE_ARCHIVED
    end if  end if    end if     end if  end if   end if    end if     end if  end if

    if newState >= 0 then
        self.ChangeTaskState(newState)
    end if


context Task::MoveToList(list: TaskList, optional order: integer = 0)
post:
    self.TaskList = list
    self.ReduceStateToBase()
    if order <> 0 then
        self.ListOrder = order
    end if

context Task::CopyToBasket(optional flags: integer = 0): ElementReference
post:
    result = user.Clipboard.Push(self.Id, self.oclType, self.ref, self.Title, self.Summary, "Task", self.href, flags)

-- to remove
context Task::IsInBasket: boolean
post:
    result = false

context Task::TogglePinned : FolderTask
post:
    let pinnedLink :FolderTask = user.PinnedFolders.Tasks.select(element.Task.Id = self.Id).first
    if pinnedLink <> null then
        pinnedLink.delete
        result = null
    else
        let maxOrder: integer = 0
        if user.PinnedFolders.Tasks.count > 0 then
            maxOrder = user.PinnedFolders.Tasks.max(element.Order)
        else if user.PinnedFolders.Notes.count > 0 then
            maxOrder = user.PinnedFolders.Notes.max(element.Order)
        else
            maxOrder = user.PinnedFolders.Folders.max(element.Order)    
        end if
        end if

        result = user.PinnedFolders.Tasks.newElement(e | e.Task = self and e.Order = maxOrder+ORDER_STEP)
    end if

context Task::IsPinned: boolean
post:
    result = user.PinnedFolders.Tasks.exists(element.Task.Id = self.Id)


context TaskNote::IsCanonical: boolean
post:
    result = (self.LinkInfo & FLI_CANONICAL) <> 0

context TaskNote::Title: string
post:
    result = self.Note.Title

context TaskNote::Summary: string
post:
    result = self.Note.Summary

context TaskNote::href: string
post:
    result = self.Note.href

context Task::CalculateCanonicalPath: string
post:
    let canonicalFolderLink: FolderTask

    let canonicalPath: JsonObject
    let parentPath: JsonObject

    canonicalFolderLink = self.InFolders.select(element.IsCanonical).first
    if canonicalFolderLink <> null then
        if not canonicalFolderLink.Folder.CanonicalPath.isEmpty then
            parentPath = new JsonObject
            parentPath.Parse(canonicalFolderLink.Folder.CanonicalPath)
            canonicalPath = [...parentPath]
        else
            canonicalPath = []
        end if
    else
        if self.TaskList <> null then
            parentPath = new JsonObject
            parentPath.Parse(self.TaskList.CanonicalPath)
            canonicalPath = [...parentPath]
        else
            if self.Actor <> null then
                canonicalPath = [
                    {
                        Name: self.Actor.Name,
                        href: self.Actor.href
                    },
                    {
                        Name: '__; en: My tasks; es: Mis tareas; pl: Moje zadania',
                        href: '/mytasks'
                    }
                ]
            else
                canonicalPath = []
            end if
        end if
    end if

    canonicalPath = [..., 
        {
            Name:       self.Title,
            Summary:    self.Summary,
            href:       self.href,
            icon:       'Task'
        }
    ]

    result = canonicalPath.ToString()


context Task::ValidateSubTreeCanonicalPaths
post:
    self.CanonicalPath = self.CalculateCanonicalPath()

    self.Notes.select(element.IsCanonical).forAll(link: TaskNote |
        link.Note.ValidateSubTreeCanonicalPaths()
    )

    self.Files.select(element.IsCanonical).forAll(link: TaskFile |
        link.File.ValidateSubTreeCanonicalPaths()
    )


context Task::RecalculateCanonicalLinksAfterAttach(newLink: FolderTask)
post:
    let changed: boolean = false
    let prevCanonicalLink: FolderTask = self.InFolders.select(element.IsCanonical).first

    let fromFolder: Folder = prevCanonicalLink.Folder
    let toFolder: Folder = newLink.Folder

    if prevCanonicalLink = null then
        newLink.LinkInfo = newLink.LinkInfo | FLI_CANONICAL
        changed = true
    else

        if toFolder.IsPublic then 
            if not fromFolder.IsPublic then
                newLink.LinkInfo = newLink.LinkInfo | FLI_CANONICAL
                prevCanonicalLink.LinkInfo = prevCanonicalLink.LinkInfo & (~FLI_CANONICAL)
                changed = true
            end if
        else
            if toFolder.IsGroupFolder then
                if fromFolder.IsPersonal then
                    newLink.LinkInfo = newLink.LinkInfo | FLI_CANONICAL
                    prevCanonicalLink.LinkInfo = prevCanonicalLink.LinkInfo & (~FLI_CANONICAL)
                    changed = true
                end if
            end if
        end if

    end if

    if changed = true then
        self.ValidateSubTreeCanonicalPaths()
    end if


context Task::GetCanonicalPath: JsonObject
post:
    if not self.CanonicalPath.isEmpty then
        result = new JsonObject
        result.Parse(self.CanonicalPath)
    else
        result = null
    end if


context Task::AttachNote(note: Note): boolean
post:
    if not self.Notes.exists(element.Note = note) then
        self.Notes.newElement(element.Note=note)
        result = true
    else
        result = false
    end if


context Task::AttachFile(f: UploadedFile): boolean
post:
    if not self.Files.exists(element.File = f) then
        self.Files.newElement(element.File=f)
        result = true
    else
        result = false
    end if


context Task::AttachClipboard(references: JsonObject): Task
post:
    let referencesNo: integer = references.count

    let reference: JsonObject
    let id: integer
    let typeName: string
    
    let note: Note
    let upFile: UploadedFile

    set(0 .. referencesNo-1).forAll(i |
        reference = references[i]
        id = reference.id
        typeName = reference.typeName
        
        select case typeName
            case 'Note'
                note = system.GetItem(id, typeName)
                if note <> null then
                    self.AttachNote(note)
                end if

            case 'UploadedFile'
                upFile = system.GetItem(id, typeName)
                if upFile <> null then
                    self.AttachFile(upFile)
                end if

        end select
    )
    result = self


context Task::CreateFile(title: string, mimeType: string, size: integer, optional order: integer=0) : TaskFile
pre Only logged in users may upload files:
    user <> null
post:
    let upFile: UploadedFile
    let fileLink: TaskFile

    upFile = user.UploadedFiles.newElement(n |  n.Title = title
                                                n.MimeType = mimeType
                                                n.Size = size)

    fileLink = self.Files.newElement( e | 
        e.File = upFile
        e.LinkInfo = FLI_CANONICAL)

    upFile.ValidateSubTreeCanonicalPaths()
    result = fileLink