-- Genaral status of Tasks, TaskLists and Projects
const STATUS_ACTIVE = 0     -- This is a data we usually work on
const STATUS_ARCHIVED = 1

const STATE_UNSPECIFIED       = 0     -- [000-999]
const STATE_IN_PREPARATION    = 1000  -- [1000-1999]
const STATE_PLANNED           = 2000  -- [2000-2999]
const STATE_READY             = 3000  -- [3000-3999]
const STATE_EXECUTING         = 4000  -- [4000 - 6999]
const STATE_FINISHED          = 7000  -- [7000 - 7999]
const STATE_CLOSED            = 8000  -- [8000 - 8999]
const STATE_ARCHIVED          = 9000  -- [9000 - 9999]

--Common used

--?enum state = [draft: 0, prepared: 1, accepted: 100, started: 101]
const ORDER_STEP        = 64

const TK_TASK           = 0
const TK_EVENT          = 1

class Task
protected:
    Title(128):             string
public:
    Summary(196):	        string
    Tags(64):               string
    Index(16):              string
    Kind:                   integer
    State:                  integer
    CreatedBy:              User <backNav: CreatedTasks>
    Actor:                  User
    DueDate:		        date
    Effort:                 integer
    Status:                 integer
    StartDate:              date
    EndDate:                date

    Steps[0..n]:	        TaskStep
    Description:	        string
    Images:                 string      <readOnly>
    AttachedFiles:          string      <readOnly>
    CanonicalPath(0):       string

    TaskList(0..1):         TaskList    <backNav: AllTasks>
    InFolders[0..n]:        FolderTask
    Notes[0..n]:            TaskNote
    Files[0..n]:            TaskFile
    InMessages[0..n]:       MessageTask
    ListOrder:              integer
    UserOrder:              integer

    TaskListId:             integer
    ActorId:                integer
    CreatedById:            integer

    CreationDate:	        date
    ModificationDate:       date
end class


class TaskStep
    Label:                  string
    Done:                   boolean
    Order:                  integer
end class

class TaskNote
    Note:                   Note <backNav: InTasks>
    Task:                   Task <backNav: Notes>
    LinkInfo:               integer
    Order:                  integer
    Role:                   integer
end class


constraint Task::TaskList
    self.TaskListId = element.Id


context Task::OnAfterCreate
post:
    self.CreationDate.SetUTCDate()
    self.ModificationDate = self.CreationDate


context Task::Finish()
post:
    self.ChangeTaskState(STATE_FINISHED)


context Task::Archive()
post:
    self.Status = STATUS_ARCHIVED

context Task::MainPage: string
post:
    result = "TaskDoc/"+self.Id

context Task::href: string
post:
    result = '/task/' + self.Id


context Task::DeletePermanently
post:
    self.InFolders.removeAll
    self.InMessages.removeAll
    self.Notes.removeAll
    self.Files.removeAll
    self.delete


context Task::SetTitle(val: string)
post:
    self.Title = val
    self.ValidateSubTreeCanonicalPaths()


context Task::GetTitle(): string
post:
    result = self.Title

context Task::ChangeTaskState(newState: integer)
post:
    if self.State <> newState then
        self.State = newState
    end if

context Task::ReduceStateToBase()
post:
    let newState: integer = -1
    if self.State < STATE_UNSPECIFIED then
        newState = STATE_UNSPECIFIED
    else if self.State > STATE_UNSPECIFIED and self.State < STATE_IN_PREPARATION then
        newState = STATE_UNSPECIFIED
    else if self.State > STATE_IN_PREPARATION and self.State < STATE_PLANNED then
        newState = STATE_IN_PREPARATION
    else if self.State > STATE_PLANNED and self.State < STATE_READY then
        newState = STATE_PLANNED
    else if self.State > STATE_READY and self.State < STATE_EXECUTING then
        newState = STATE_READY
    else if self.State > STATE_EXECUTING and self.State < STATE_FINISHED then
        newState = STATE_EXECUTING
    else if self.State > STATE_FINISHED and self.State < STATE_CLOSED then
        newState = STATE_FINISHED
    else if self.State > STATE_CLOSED and self.State < STATE_ARCHIVED then
        newState = STATE_ARCHIVED
    else if self.State > STATE_ARCHIVED then
        newState = STATE_ARCHIVED
    end if  end if    end if     end if  end if   end if    end if     end if  end if

    if newState >= 0 then
        self.ChangeTaskState(newState)
    end if


context Task::MoveToList(list: TaskList, optional order: integer = 0)
post:
    self.TaskList = list
    list.NormalizeTaskState(self)
    if order <> 0 then
        self.ListOrder = order
    end if

context Task::CopyToBasket(optional flags: integer = 0): ElementReference
post:
    result = user.Clipboard.Push(self.Id, self.oclType, self.ref, self.Title, self.Summary, self.icon, self.href, flags)

-- to remove
context Task::IsInBasket: boolean
post:
    result = false

context Task::TogglePinned : FolderTask
post:
    let pinnedLink :FolderTask = user.PinnedFolders.Tasks.select(element.Task.Id = self.Id).first
    if pinnedLink <> null then
        pinnedLink.delete
        result = null
    else
        let maxOrder: integer = 0
        if user.PinnedFolders.Tasks.count > 0 then
            maxOrder = user.PinnedFolders.Tasks.max(element.Order)
        else if user.PinnedFolders.Notes.count > 0 then
            maxOrder = user.PinnedFolders.Notes.max(element.Order)
        else
            maxOrder = user.PinnedFolders.Folders.max(element.Order)
        end if
        end if

        result = user.PinnedFolders.Tasks.newElement(e | e.Task = self and e.Order = maxOrder+ORDER_STEP)
    end if

context Task::IsPinned: boolean
post:
    result = user.PinnedFolders.Tasks.exists(element.Task.Id = self.Id)


context TaskNote::IsCanonical: boolean
post:
    result = (self.LinkInfo & FLI_CANONICAL) <> 0

context TaskNote::Title: string
post:
    result = self.Note.Title

context TaskNote::SetTitle(value: string)
post:
    self.Note.Title = value

context TaskNote::Summary: string
post:
    result = self.Note.Summary

context TaskNote::SetSummary(value: string)
post:
    self.Note.Summary = value

context TaskNote::href: string
post:
    result = self.Note.href

context TaskNote::icon: string
post:
    result = self.Note.icon

context TaskNote::SetLocationAsCanonical
post:
    self.Note.InFolders.select(element.IsCanonical).forAll(element.LinkInfo = element.LinkInfo & (~FLI_CANONICAL))
    self.Note.InNotes.select(element.IsCanonical).forAll(element.LinkInfo = element.LinkInfo & (~FLI_CANONICAL))
    self.Note.InTasks.select(element.IsCanonical).forAll(element.LinkInfo = element.LinkInfo & (~FLI_CANONICAL))

    self.LinkInfo = self.LinkInfo | FLI_CANONICAL
    self.Note.ValidateSubTreeCanonicalPaths()


context TaskNote::AttachMeTo(references: JsonObject)
post:
    self.Note.AttachMeTo(references)


context TaskNote::InTitle: string
post:
    result = self.Task.Title

context TaskNote::InSummary: string
post:
    result = self.Task.Summary

context TaskNote::InHRef: string
post:
    result = self.Task.href

context TaskNote::InIcon: string
post:
    result = self.Task.icon

context TaskNote::ToggleDescriptionRole: TaskNote
post:
    if self.Role = NR_DESCRIPTION then
        self.Role = NR_NONE
    else
        self.Role = NR_DESCRIPTION
    end if
    result = self

context TaskNote::MoveUp: TaskNote
post:
    let prevNote: TaskNote = self.Task.Notes.orderedBy("Order").select(element.Order < self.Order).last
    let prevNoteOrder: integer = prevNote.Order
    if prevNote <> null then
        prevNote.Order = self.Order
        self.Order = prevNoteOrder
    end if
    result = self

context TaskNote::MoveDown: TaskNote
post:
    let nextNote: TaskNote = self.Task.Notes.orderedBy("Order").select(element.Order > self.Order).first
    let nextNoteOrder: integer = nextNote.Order
    if nextNote <> null then
        nextNote.Order = self.Order
        self.Order = nextNoteOrder
    end if
    result = self



context Task::CalculateCanonicalPath: string
post:
    let parentPath: JsonObject
    let canonicalPath: JsonObject

    let canonicalFolderLink: FolderTask
    let parentFolder: Folder

    if self.TaskList <> null then
        parentPath = new JsonObject
        parentPath.Parse(self.TaskList.CanonicalPath)
        if parentPath.count > 0 then
            canonicalPath = [...parentPath]
        else
            canonicalPath = []
        end if
        canonicalPath = [...,
            {
                Name:       self.TaskList.Name,
                Summary:    self.TaskList.Summary,
                href:       self.TaskList.href,
                icon:       'TaskList'
            }]
    else
        canonicalFolderLink = self.InFolders.select(element.IsCanonical).first
        if canonicalFolderLink <> null then
            parentFolder = canonicalFolderLink.Folder
            if not parentFolder.CanonicalPath.isEmpty then
                parentPath = new JsonObject
                parentPath.Parse(parentFolder.CanonicalPath)
                if parentPath.count > 0 then
                    canonicalPath = [...parentPath]
                else
                    canonicalPath = []
                end if
                canonicalPath = [...,
                    {
                        Name: parentFolder.Title,
                        Summary: parentFolder.Summary,
                        href: parentFolder.href,
                        icon: parentFolder.icon
                    }]
            else
                canonicalPath = []
            end if
        else
            if self.Actor <> null then
                canonicalPath = [
                    {
                        Name: '__; en: My tasks; es: Mis tareas; pl: Moje zadania',
                        href: '/mytasks'
                    }
                ]
            else
                canonicalPath = []
            end if
        end if
    end if

    result = canonicalPath.ToString()


context Task::ValidateSubTreeCanonicalPaths
post:
    self.CanonicalPath = self.CalculateCanonicalPath()

    self.Notes.select(element.IsCanonical).forAll(link: TaskNote |
        link.Note.ValidateSubTreeCanonicalPaths()
    )

    self.Files.select(element.IsCanonical).forAll(link: TaskFile |
        link.File.ValidateSubTreeCanonicalPaths()
    )


context Task::RecalculateCanonicalLinksAfterAttach(newLink: FolderTask)
post:
    let changed: boolean = false
    let prevCanonicalLink: FolderTask = self.InFolders.select(element.IsCanonical).first

    let fromFolder: Folder = prevCanonicalLink.Folder
    let toFolder: Folder = newLink.Folder

    if prevCanonicalLink = null then
        newLink.LinkInfo = newLink.LinkInfo | FLI_CANONICAL
        changed = true
    else

        if toFolder.IsPublic then
            if not fromFolder.IsPublic then
                newLink.LinkInfo = newLink.LinkInfo | FLI_CANONICAL
                prevCanonicalLink.LinkInfo = prevCanonicalLink.LinkInfo & (~FLI_CANONICAL)
                changed = true
            end if
        else
            if toFolder.IsGroupFolder then
                if fromFolder.IsPersonal then
                    newLink.LinkInfo = newLink.LinkInfo | FLI_CANONICAL
                    prevCanonicalLink.LinkInfo = prevCanonicalLink.LinkInfo & (~FLI_CANONICAL)
                    changed = true
                end if
            end if
        end if

    end if

    if changed = true then
        self.ValidateSubTreeCanonicalPaths()
    end if


context Task::GetCanonicalPath: JsonObject
post:
    if not self.CanonicalPath.isEmpty then
        result = new JsonObject
        result.Parse(self.CanonicalPath)
    else
        result = null
    end if


context Task::AttachNote(note: Note): boolean
post:
    if not self.Notes.exists(element.Note = note) then
        self.Notes.newElement(element.Note=note and element.Order = self.MaxOrder + ORDER_STEP)
        result = true
    else
        result = false
    end if


context Task::AttachFile(f: UploadedFile): boolean
post:
    if not self.Files.exists(element.File = f) then
        self.Files.newElement(element.File=f and element.Order = self.MaxOrder + ORDER_STEP)
        result = true
    else
        result = false
    end if


context Task::AttachClipboard(references: JsonObject): Task
post:
    let referencesNo: integer = references.count

    let reference: JsonObject
    let id: integer
    let typeName: string

    let note: Note
    let upFile: UploadedFile

    set(0 .. referencesNo-1).forAll(i |
        reference = references[i]
        id = reference.id
        typeName = reference.typeName

        select case typeName
            case 'Note'
                note = system.GetItem(id, typeName)
                if note <> null then
                    self.AttachNote(note)
                end if

            case 'UploadedFile'
                upFile = system.GetItem(id, typeName)
                if upFile <> null then
                    self.AttachFile(upFile)
                end if

        end select
    )
    result = self


context Task::MaxOrder: integer
post:
    let n: integer = self.Notes.max(element.Order)
    let s: integer = self.Files.max(element.Order)

    result = n
    if s > result then
        result = s
    end if

context Task::CreateFile(title: string, mimeType: string, size: integer, optional order: integer=0) : TaskFile
pre Only logged in users may upload files:
    user <> null
post:
    let upFile: UploadedFile
    let fileLink: TaskFile

    upFile = user.UploadedFiles.newElement(n |  n.Title = title
                                                n.MimeType = mimeType
                                                n.Size = size)
    if order = 0 then
        order = self.MaxOrder + ORDER_STEP
    end if

    fileLink = self.Files.newElement( e |
        e.File = upFile
        e.LinkInfo = FLI_CANONICAL
        e.Order = order)

    upFile.ValidateSubTreeCanonicalPaths()
    result = fileLink


context Task::CopyNoteToBasket(noteLink: TaskNote, optional flags: integer=0): ElementReference
post:
    result = noteLink.Note.CopyToBasket(flags)

context Task::CutNoteToBasket(noteLink: TaskNote): ElementReference
post:
    result = self.CopyNoteToBasket(noteLink, EIF_CUT)
    self.DettachNote(noteLink)


context Task::CopyFileToBasket(fileLink: TaskFile, optional flags: integer=0): ElementReference
post:
    result = fileLink.File.CopyToBasket(flags)


context Task::CutFileToBasket(fileLink: TaskFile): ElementReference
post:
    result = self.CopyFileToBasket(fileLink, EIF_CUT)
    self.DettachFile(fileLink)


context Task::DettachNote(noteLink: TaskNote)
pre:
    noteLink.Task.Id = self.Id
post:
    noteLink.delete


context Task::DettachFile(fileLink: TaskFile)
pre:
    fileLink.Task.Id = self.Id
post:
    fileLink.delete

context Task::DeletePermanentlyNote(noteLink: TaskNote)
post:
    let note: Note = noteLink.Note
    note.DeletePermanently()


context Task::DeletePermanentlyFile(fileLink: TaskFile)
post:
    let upFile: UploadedFile = fileLink.File
    upFile.DeletePermanently()



context Task::icon: string
post:
    if self.State >= STATE_FINISHED then
        result = 'square-check-big'
    else
        result = 'square-pen'
    end if


context Task::AttachMeTo(references: JsonObject)
post:
    let referencesNo: integer = references.count

    let reference: JsonObject
    let id: integer
    let typeName: string

    let folder: Folder
    let list: TaskList

    set(0 .. referencesNo-1).forAll(i |
        reference = references[i]
        id = reference.id
        typeName = reference.typeName

        select case typeName
            case 'Folder'
                folder = system.GetItem(id, typeName)
                if folder <> null then
                    folder.AttachTask(self)
                end if

            case 'TaskList'
                list = system.GetItem(id, typeName)
                if list <> null then
                    self.MoveToList(list)
                end if

        end select
    )


context Task::CreateSubNote(title: string, optional order: integer=0, optional summary: string = ""): TaskNote
post:
    let note: Note = user.CreatedNotes.newElement(element.Title = title and element.Summary = summary)

    if order = 0 then
        order = self.MaxOrder + ORDER_STEP
    end if

    --result = self.Notes.newElement(element.Note = note and element.Order = order)
    result = self.Notes.newElement(element.Note = note and element.Order = order)
    result.SetLocationAsCanonical()

context Task::AddDescription(title: string, optional order: integer=0): TaskNote
post:
    let note: Note = user.CreatedNotes.newElement(element.Title = title)

    if order = 0 then
        order = self.MaxOrder + ORDER_STEP
    end if

    --result = self.Notes.newElement(element.Note = note and element.Order = order)
    result = self.Notes.newElement(element.Note = note and element.Order = order and element.Role = NR_DESCRIPTION)
    result.SetLocationAsCanonical()


context Task::ReorderNotes(optional fromOrder: integer = 0): integer
post:
    let order: integer = MIN_USER_TASK_ORDER in
    self.Notes.orderedBy('Order').forAll(element.Order = order and order = order + 1)
    order = (order - MIN_USER_TASK_ORDER) * ORDER_STEP + fromOrder
    result = order
    self.Notes.orderedBy('Order').revForAll(element.Order = order and order = order - ORDER_STEP)


context Task::ReorderFiles(optional fromOrder: integer = 0): integer
post:
    let order: integer = MIN_USER_TASK_ORDER in
    self.Files.orderedBy('Order').forAll(element.Order = order and order = order + 1)
    order = (order - MIN_USER_TASK_ORDER) * ORDER_STEP + fromOrder
    result = order
    self.Files.orderedBy('Order').revForAll(element.Order = order and order = order - ORDER_STEP)

context Task::ReorderAttachements()
post:
    let lastOrder: integer = 0
    lastOrder = self.ReorderNotes(lastOrder)
    lastOrder = self.ReorderFiles(lastOrder)
