const TLK_KANBAN_CHECKLIST     =  0
const TLK_KANBAN_PROCESS   =  1
const TLK_LIST              =  2
const TLK_CALENDAR          =  3
const TLK_DAY               = 10
const TLK_WEEK              = 11
const TLK_MONTH             = 12

const TLS_GROUP_ACTIVE_LIST     = 0
const TLS_GROUP_TEMPLATE_LIST   = 1
const TLS_GROUP_ARCHVIVED_LIST  = 1000


class TaskList
protected:
    Name(128):              string
public:
    Summary(196):           string
    Tasks(0..n):            Task
    AllTasks(0..n):         Task            <backNav: TaskList>
    Order:                  integer
    TaskStates:             string
    Archived:               boolean
    IndexPrefix:            string
    Kind:                   integer
    Status:                 integer
    CanonicalPath(0):       string
    User:                   User            <backNav: MyLists>
    Group:                  Group
    InGroup:                Group
    GroupId:                integer

    SubscribedBy(0..n):     UserTaskList     <backNav: List>
end class


class UserTaskList
    User:                   User            <backNav: SubscribedLists>
    List:                   TaskList        <backNav: SubscribedBy>
    LinkInfo:               integer
    Order:                  integer
    Role:                   integer
end class



constraint TaskList::Tasks
    element.TaskListId = self.Id and element.Status = STATUS_ACTIVE



constraint TaskList::AllTasks
    element.TaskListId = self.Id


constraint TaskList::Group
    self.GroupId = element.Id


context TaskList::SwitchToList
post:
    if self.Kind = TLK_KANBAN_CHECKLIST then
        self.Kind = TLK_LIST
    end if


context TaskList::SwitchToKanban
post:
    if self.Kind = TLK_LIST then
        self.Kind = TLK_KANBAN_CHECKLIST
    end if

context TaskList::SwitchToCalendar
post:
    self.Kind = TLK_CALENDAR

context TaskList::href: string
post:
    select case self.Kind
    case TLK_KANBAN_CHECKLIST --0:
        result = '/listboard/' + self.Id
    case TLK_KANBAN_PROCESS --0:
        result = '/listboard/' + self.Id
    case TLK_LIST
        result = '/tasklist/' + self.Id
    case TLK_CALENDAR
        result = '/listboard/' + self.Id
    case TLK_DAY
        result = '/tasklist/' + self.Id
    case else
        result = '/tasklist/' + self.Id
    end select



context TaskList::FinishAll()
post:
    self.Tasks.select(element.State <> STATE_FINISHED).forAll(element.Finish())


context TaskList::Archive()
post:
    self.Tasks.forAll(element.Archive())
    self.Archived = true
    self.Status = TLS_GROUP_ARCHVIVED_LIST

context TaskList::CreateTaskC(t: string): Task
post:
    let task: Task = new Task
    task.Title = t
    self.Tasks.insert(task)



context TaskList::CreateTaskEx(properties: JsonObject): Task
post:
    let task: Task = user.CreatedTasks.newElement in
    task.TaskList = self
    
    task.Title = properties.Title
    task.Summary = properties.Summary
    task.Description = properties.Description
    task.ListOrder = properties.ListOrder
    task.State = properties.State
    task.Tags = properties.Tags
    task.Status = STATUS_ACTIVE


    if self.IndexPrefix.Len <> 0 then
        task.Index = self.IndexPrefix + '-' + (self.Tasks.count + 1)
    else if self.Group <> null then
        self.Group.TaskIndexCounter = self.Group.TaskIndexCounter + 1
        task.Index = self.Group.ListIndexPrefix + '-' + self.Group.TaskIndexCounter
    end if
    end if


    result = task


--context TaskList::CreateTask(title: string, summary: string, state: integer, optional tags: string, optional actor: User): Task
--post:
--    let props :JsonObject = {
--        Title: title,
--        Summary: summary,
--        State: state,
--        Tags: tags
--    }
--
--    result = self.CreateTaskEx(props)
--    result.Actor = actor


context TaskList::CreateTask(title: string, summary: string, state: integer, optional tags: string, optional actor: User): Task
post:
    let task: Task = self.Tasks.newElement(t| t.Title = title and t.Summary = summary and t.State = state and t.Tags = tags and t.Actor = actor) in
    if self.IndexPrefix.Len <> 0 then
        task.Index = self.IndexPrefix + '-' + (self.Tasks.count + 1)
    else if self.Group <> null then
        self.Group.TaskIndexCounter = self.Group.TaskIndexCounter + 1
        task.Index = self.Group.ListIndexPrefix + '-' + self.Group.TaskIndexCounter
    end if
    end if

    result = task


context TaskList::CreateJTask(title: string, summary: string, state: integer, optional tags: string, optional actor: User): Task
post:
    let props :JsonObject = {
        Title: title,
        Summary: summary,
        State: state,
        Tags: tags
    }

    result = self.CreateTaskEx(props)
    result.Actor = actor


context TaskList::TasksCount: integer
post:
    result = self.Tasks.count

context TaskList::TasksInfo: string
post:
    result = self.Tasks.sum(element.Title + "; ")


context TaskList::SetName(val: string)
post:
    self.Name = val
    self.ValidateSubTreeCanonicalPaths()


context TaskList::GetName(): string
post:
    result = self.Name

-- ===========================================================================================


context TaskList::GetTaskStates(): JsonObject
post:
    if self.TaskStates.Len <> 0 then
        result = new JsonObject
        result.Parse(self.TaskStates)
    else
        result = [
            {
                name: '__; en: To do; es: Por hacer; pl: Do zrobienia',
                state: STATE_UNSPECIFIED
            },
            {
                name: '__; en: Finished; es: Terminado; pl: Zakończone',
                state: STATE_FINISHED
            }
        ]

        self.TaskStates = result.ToString()
    end if



context TaskList::AddColumn(pos: integer, optional state: integer = 0, optional name: string = ""): JsonObject
post:
    if self.Kind = TLK_KANBAN_CHECKLIST then
        result = self.AddChecklistColumn(pos, state, name)
    else if self.Kind = TLK_KANBAN_PROCESS then
        result = self.AddProcessColumn(pos, state, name)
    end if
    end if


context TaskList::AddChecklistColumn(pos: integer, optional state: integer, optional name: string): JsonObject
pre:
    self.TaskStates.Len <> 0
post:
    let prevStates: JsonObject = new JsonObject
    prevStates.Parse(self.TaskStates)

    let columnsNo: integer = prevStates.count

    let maxToDoState: integer = 0
    let todoStates: JsonObject = []
    let colState: integer

    set(0 .. columnsNo-1).forAll(i |
        colState = prevStates[i].state

        if colState < STATE_FINISHED then
            todoStates = [..., prevStates[i]]
            if colState > maxToDoState then
                maxToDoState = colState
            end if
        end if
    )


    if state = 0 then
        state = maxToDoState + 1
    end if

    if name.Len = 0 then
        name = "To Do (" + todoStates.count + ")"
    end if

    let newColumn: JsonObject = {
        name: name,
        state: state
    }

    let states: JsonObject = []

    if pos > 0 then
        set(0 .. pos - 1).forAll(i |
            states = [..., prevStates[i]]
        )
    end if

    states = [..., newColumn]

    if pos < columnsNo then
        set(pos .. columnsNo-1).forAll(j |
            states = [..., prevStates[j]]
        )
    end if

    self.TaskStates = states.ToString
    result = states


context TaskList::AddProcessColumn(pos: integer, state: integer, name: string): JsonObject
pre:
    self.TaskStates.Len <> 0
post:
    let prevStates: JsonObject = new JsonObject
    prevStates.Parse(self.TaskStates)

    let columnsNo: integer = prevStates.count

    let canAddColumn: boolean = true
    let colState: integer
    set(0 .. columnsNo-1).forAll(i |
        colState = prevStates[i].state
        if colState = state then
            canAddColumn = false
        end if
    )

    if canAddColumn then
        let newColumn: JsonObject = {
            name: name,
            state: state
        }

        let states: JsonObject = []

        if pos > 0 then
            set(0 .. pos - 1).forAll(i |
                states = [..., prevStates[i]]
            )
        end if

        states = [..., newColumn]

        if pos < columnsNo then
            set(pos .. columnsNo-1).forAll(j |
                states = [..., prevStates[j]]
            )
        end if
        self.TaskStates = states.ToString
        result = states
    else
        result = null
    end if

context TaskList::MoveColumn(pos: integer, shift: integer): JsonObject
pre:
    self.TaskStates.Len <> 0
post:
    let prevStates: JsonObject = new JsonObject
    prevStates.Parse(self.TaskStates)

    let statesNo: integer = prevStates.count
    let newPos: integer = pos + shift
    if newPos < 0 then
        newPos = 0
    else if newPos >= statesNo then
        newPos = statesNo-1
    end if
    end if

    if newPos = pos then
        result = prevStates
    else
        let states: JsonObject = []

        if newPos < pos then
            set(0 .. newPos-1).forAll(i |
                states = [..., prevStates[i]]
            )

            states = [..., prevStates[pos]]

            set(newPos .. pos-1).forAll(i |
                states = [..., prevStates[i]]
            )

            set(pos+1 .. statesNo-1).forAll(i |
                states = [..., prevStates[i]]
            )
        else
            set(0 .. pos-1).forAll(i |
                states = [..., prevStates[i]]
            )

            set(pos+1 .. newPos).forAll(i |
                states = [..., prevStates[i]]
            )

            states = [..., prevStates[pos]]

            set(newPos+1 .. statesNo-1).forAll(i |
                states = [..., prevStates[i]]
            )
        end if

        self.TaskStates = states.ToString()
        result = states
    end if

context TaskList::ChangeColumnName(pos: integer, newName: string): JsonObject
pre:
    self.TaskStates.Len <> 0
post:
    let prevStates: JsonObject = new JsonObject
    prevStates.Parse(self.TaskStates)

    let columnsNo: integer = prevStates.count

    let states: JsonObject = []
    set(0 .. pos-1).forAll(i |
        states = [..., prevStates[i]]
    )

    let changedColumn: JsonObject = {
        name: newName,
        state: prevStates[pos].state,
    }

    states = [..., changedColumn]

    set(pos+1 .. columnsNo).forAll(i |
        states = [..., prevStates[i]]
    )

    self.TaskStates = states.ToString()
    result = states

context TaskList::RemoveColumn(pos: integer, optional moveTasksTo: integer=STATE_UNSPECIFIED): JsonObject
post:
     if self.Kind = TLK_KANBAN_CHECKLIST then
        result = self.RemoveChecklistColumn(pos, moveTasksTo)
    else if self.Kind = TLK_KANBAN_PROCESS then
        result = self.RemoveProcessColumn(pos, moveTasksTo)
    end if
    end if

context TaskList::RemoveChecklistColumn(pos: integer, optional moveTasksTo: integer=STATE_UNSPECIFIED): JsonObject
pre:
    self.TaskStates.Len <> 0
post:
    let prevStates: JsonObject = new JsonObject
    prevStates.Parse(self.TaskStates)

    let columnsNo: integer = prevStates.count
    let states: JsonObject = []

    set(0 .. pos-1).forAll(i |
        states = [..., prevStates[i]]
    )

    set(pos+1 .. columnsNo-1).forAll(i |
        states = [..., prevStates[i]]
    )

    let removingState: integer = prevStates[pos].state
    self.Tasks.forAll(t |
        if t.State = removingState then
            t.ChangeTaskState(moveTasksTo)
        end if
    )

    self.TaskStates = states.ToString()
    result = states

context TaskList::RemoveProcessColumn(pos: integer, optional moveTasksTo: integer=STATE_UNSPECIFIED): JsonObject
pre:
    self.TaskStates.Len <> 0
post:
    let prevStates: JsonObject = new JsonObject
    prevStates.Parse(self.TaskStates)

    let columnsNo: integer = prevStates.count
    let states: JsonObject = []

    set(0 .. pos-1).forAll(i |
        states = [..., prevStates[i]]
    )

    set(pos+1 .. columnsNo-1).forAll(i |
        states = [..., prevStates[i]]
    )

    let removingState: integer = prevStates[pos].state
    self.Tasks.forAll(t |
        if t.State = removingState then
            t.ChangeTaskState(moveTasksTo)
        end if
    )

    self.TaskStates = states.ToString()
    result = states


context TaskList::CreateTaskInColumn(properties: JsonObject, pos: integer): Task
pre:
    self.TaskStates.Len <> 0
post:
    result = self.CreateTaskEx(properties)

    let states: JsonObject = new JsonObject
    states.Parse(self.TaskStates)

    let newTaskState: integer = states[pos].state
    result.ChangeTaskState(newTaskState)


context TaskList::ChangeTaskColumn(task: Task, columnNo: integer): Task
pre:
    self.TaskStates.Len <> 0
post:
    let states: JsonObject = new JsonObject
    states.Parse(self.TaskStates)

    let newState: integer = states[columnNo].state
    task.ChangeTaskState(newState)
    result = task




context TaskList::ChangeListKind(template: JsonObject): string
post:
    self.Kind = template.Kind

    let newTaskStates: string = template.TaskStates.ToString()

    if self.TaskStates <> newTaskStates then
        self.Tasks.forAll(self.NormalizeTaskState(element))
    end if

    self.TaskStates = newTaskStates

    self.ValidateSubTreeCanonicalPaths()

    result = self.href()


context TaskList::NormalizeTaskState(task: Task): integer
pre:
    self.TaskStates.Len <> 0
post:
    let states: JsonObject = new JsonObject
    states.Parse(self.TaskStates)

    let statesNo: integer = states.count
    
    let columnState: integer
    let bestState: integer

    if statesNo > 0 then
        bestState = states[0].state
    else
        bestState = 0
    end if

    set(0 .. statesNo-1).forAll(i | 
        columnState = states[i].state

        if task.State >= columnState then
            bestState = columnState
        end if

    )

    task.ChangeTaskState(bestState)
    result = bestState


context TaskList::CopyToBasket(optional flags: integer = 0): ElementReference 
post:
    result = user.Clipboard.Push(self.Id, self.oclType, self.ref, self.Name, self.Summary, "notebook", self.href, flags)


context TaskList::CopyTaskToBasket(task: Task, optional flags: integer = 0): ElementReference 
post:
    result = user.Clipboard.Push(task.Id, task.oclType, task.ref, task.Title, task.Summary, task.icon, task.href, flags)


context TaskList::CutTaskToBasket(task: Task, optional flags: integer = 0): ElementReference 
post:
    result = user.Clipboard.Push(task.Id, task.oclType, task.ref, task.Title, task.Summary, task.icon, task.href, flags)
    task.TaskList = null
    

context TaskList::AttachClipboard(references: JsonObject): TaskList
post:
    let referencesNo: integer = references.count
    let maxOrder: integer = self.Tasks.max(element.ListOrder)
    let order: integer = maxOrder + ORDER_STEP

    let reference: JsonObject
    let id: integer
    let typeName: string
    let flags: integer

    let task: Task
    
    set(0 .. referencesNo-1).forAll(i |
        reference = references[i]
        id = reference.id
        typeName = reference.typeName
        flags = reference.flags         -- todo: EIF_CUT handle

        select case typeName
            case 'Task'
                task = system.GetItem(id, typeName)
                if task <> null then
                    if task.MoveToList(self, order) then
                        order = order + ORDER_STEP
                    end if        
                end if
        end select
    )
    result = self



context TaskList::CalculateCanonicalPath: string
post:
    let canonicalPath: JsonObject

    if self.User <> null then
        canonicalPath = [
            {
                Name: '__; en: My lists; es: Mis listas; pl: Moje listy',
                href: '/mylists'
            }
        ]
    else
        canonicalPath = [
            {
                Name: '__; en: Common lists; es: Listas comunes; pl: Wspólne listy',
                href: '/alllists'
            }
        ]
    end if

    result = canonicalPath.ToString()

context TaskList::GetCanonicalPath: JsonObject
post:
    if not self.CanonicalPath.isEmpty then
        result = new JsonObject
        result.Parse(self.CanonicalPath)
    else
        result = null
    end if

context TaskList::ValidateSubTreeCanonicalPaths
post:
    self.CanonicalPath = self.CalculateCanonicalPath()

    self.Tasks.forAll(task: Task |
        if not task.InFolders.exists(element.IsCanonical) then
            task.ValidateSubTreeCanonicalPaths()
        end if
    )


context TaskList::Subscribe: UserTaskList
post:
    let maxOrder: integer
    
    result = user.SubscribedLists.select(element.List = self).first

    if result = null then
        maxOrder = user.SubscribedLists.max(element.Order) + ORDER_STEP
        result = user.SubscribedLists.newElement(element.List = self and element.Order = maxOrder)
    end if


context TaskList::Unsubscribe: boolean
post:
    let subEntry: UserTaskList = user.SubscribedLists.select(element.List = self).first
    if subEntry <> null then
        subEntry.delete
        result = true
    else
        result = false
    end if

context TaskList::IsSubscribed: boolean
post:
    result = user.SubscribedLists.exists(element.List = self)

-- =====================================================================================

context UserTaskList::Name: string
post:
    result = self.List.Name

context UserTaskList::SetName(value: string)
post:
    self.List.Name = value

context UserTaskList::Title: string
post:
    result = self.List.Name

context UserTaskList::SetTitle(value: string)
post:
    self.List.Name = value

context UserTaskList::Summary: string
post:
    result = self.List.Summary

context UserTaskList::SetSummary(value: string)
post:
    self.List.Summary = value

context UserTaskList::href: string
post:
    result = self.List.href

context UserTaskList::MoveUp: UserTaskList
post:
    let prevList: UserTaskList = self.User.SubscribedLists.orderedBy("Order").select(element.Order < self.Order).last
    let prevListOrder: integer = prevList.Order
    if prevList <> null then
        prevList.Order = self.Order
        self.Order = prevListOrder
    end if
    result = self

context UserTaskList::MoveDown: UserTaskList
post:
    let nextList: UserTaskList = self.User.SubscribedLists.orderedBy("Order").select(element.Order > self.Order).first
    let nextListOrder: integer = nextList.Order
    if nextList <> null then
        nextList.Order = self.Order
        self.Order = nextListOrder
    end if
    result = self

context UserTaskList::IsPersonal: boolean
post:
    result = self.List.User <> null

context UserTaskList::IsInGroup(g: Group): boolean
post:
    if self.List.InGroup = g then
        result = true
    else
        result = false
    end if