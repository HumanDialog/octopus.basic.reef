
const NK_DOCUMENT          = 0
const NK_THREAD            = 1
const NK_POST              = 2


const NS_PUBLISHED_NOTE = 10


const NS_PUBLIC            = 100

class Note
protected:
    Title(128):             string
    Summary(196):	        string
    Tags(64):               string
    Index(16):              string
    Content:	            string
public:
    Kind:                   integer
    State:                  integer
    Status:                 integer
    CreationDate:	        date
    ModificationDate:       date
    CreatedBy:              User
    ModifiedBy:             User

    Images:                 string      <readOnly>
    AttachedFiles:          string      <readOnly>
    CanonicalPath(0):       string
    InFolders[0..n]:        FolderNote
    InTasks[0..n]:          TaskNote
    InMessages[0..n]:       MessageNote

    Notes[0..n]:            NoteNote
    Files[0..n]:            NoteFile
    InNotes[0..n]:          NoteNote
    NotesCount:             integer
end class


class NoteNote
    Title(128):             string
    Order:                  integer
    LinkInfo:               integer
    Note(0..1):             Note      <backNav: InNotes[0..n]>
    InNote(0..1):           Note      <backNav: Notes[0..n]>
    InNoteId:               integer
    NoteId:                 integer
end class


context Note::OnAfterCreate
post:
    self.CreationDate.SetUTCDate()
    self.CreatedBy = user

    self.ModificationDate = self.CreationDate
    self.ModifiedBy = self.CreatedBy



constraint Note::Notes
    element.InNoteId = self.Id

context Note
inv:
    self.NotesCount = self.Notes.count

context Note::href: string
post:
    select case self.Kind
        case NK_DOCUMENT
            result = '/note/' + self.Id
        case NK_THREAD
            result = '/thread/' + self.Id
        case NK_POST
            result = '/thread/' + self.InNotes.select(element.InNote.Kind=NK_THREAD).first.InNote.Id + '?res=' + self.Id

    end select



context Note::DeletePermanently
post:
    self.InFolders.removeAll
    self.InTasks.removeAll
    self.InMessages.removeAll
    self.delete

context Note::UpdateMetaInfo
post:
    self.ModificationDate.SetUTCDate()
    self.ModifiedBy = user


context Note::SetTitle(val: string)
post:
    self.Title = val
    self.UpdateMetaInfo()
    self.ValidateSubTreeCanonicalPaths()


context Note::GetTitle(): string
post:
    result = self.Title

--context Note::Title_Set(val: string)
--post:
--    self.SetTitle(val)
--
--context Note::Title_Get(): string
--post:
--    result = self.GetTitle()

context Note::SetSummary(val: string)
post:
    self.Summary = val

context Note::GetSummary(): string
post:
    result = self.Summary

--context Note::Summary_Set(val: string)
--post:
--    self.SetSummary(val)
--
--context Note::Summary_Get(): string
--post:
--    result = self.GetSummary()

context Note::SetTags(val: string)
post:
    self.Tags = val
    self.UpdateMetaInfo()


context Note::GetTags: string
post:
    result = self.Tags


--context Note::Tags_Set(val: string)
--post:
--    self.SetTags(val)
--
--context Note::Tags_Get(): string
--post:
--    result = self.GetTags()

context Note::SetIndex(val: string)
post:
    self.Index = val
    self.UpdateMetaInfo()


context Note::GetIndex: string
post:
    result = self.Index

--context Note::Index_Set(val: string)
--post:
--    self.SetIndex(val)
--
--context Note::Index_Get: stirng
--post:
--    result = self.GetIndex()

context Note::GetContent: string
post:
    result = self.Content

context Note::SetContent(val: string)
post:
    self.Content = val

    if self.Kind = NK_POST or self.Kind = NK_THREAD then
        self.Summary = self.Content.textFromHTML(128, true)
    end if

    self.UpdateMetaInfo()


--context Note::Content_Set(val: string)
--post:
--    self.SetContent(val)
--
--context Note::Content_Get(): string
--post:
--    result = self.GetContent

context Note::AddPost(content: string): NoteNote
pre:
    self.Kind = NK_THREAD
post:
    let n: Note = user.CreatedNotes.newElement() in
    --let n: Note = new Note
    n.Title = "Re: " + self.Title
    n.Content = content
    n.Summary = content.textFromHTML(128, true)
    n.Kind = NK_POST

    let maxOrder: integer = self.Notes.max(element.Order)
    result = self.Notes.newElement(element.Note=n and element.Order=maxOrder+ORDER_STEP)

    self.MoveOnForumFolderTop()
    self.UpdateMetaInfo()
    self.UpdateLatestGroupActivity()


context Note::AttachPost(note: Note, content: string): NoteNote
pre:
    self.Kind = NK_THREAD
post:
    let maxOrder: integer = self.Notes.max(element.Order)
    note.Title = "Re: " + self.Title
    note.Content = content
    note.Summary = content.textFromHTML(128, true)
    note.Kind = NK_POST

    result = self.Notes.newElement(element.Note=note and element.Order=maxOrder+ORDER_STEP)

    self.MoveOnForumFolderTop()
    self.UpdateMetaInfo()
    self.UpdateLatestGroupActivity()


context Note::MoveOnForumFolderTop()
pre:
    self.Kind = NK_THREAD
post:
    let link :FolderNote = self.InFolders.select(element.Folder.Kind = FK_DISCUSSION and element.Folder.Status <> FS_LATEST_ELEMENTS).first
    let maxOrder:integer = link.Folder.Notes.max(element.Order)
    if link.Order <> maxOrder then
        link.Order = maxOrder + ORDER_STEP
    end if

context Note::UpdateLatestGroupActivity()
pre:
    self.Kind = NK_THREAD
post:
    let latestsFolder: Folder = group.GetLatestDiscussionsFolder
    let maxOrder: integer = latestsFolder.Notes.max(element.Order)
    let latestLink: FolderNote = latestsFolder.Notes.select(element.Note = self).first

    if latestLink = null then
        latestLink = latestsFolder.Notes.newElement(e | e.Note = self and e.Order = maxOrder + ORDER_STEP)
        if latestsFolder.Notes.count > 10 then
            latestsFolder.Notes.orderedBy("Order").first.delete
        end if
    else
        if latestLink.Order <> maxOrder then
            latestLink.Order = maxOrder + ORDER_STEP
        end if
    end if


context Note::CopyToBasket(optional flags: integer=0): ElementReference
post:
    result = user.Clipboard.Push(self.Id, self.oclType, self.ref, self.Title, self.Summary, "Note", self.href, flags)


-- to remove
context Note::IsInBasket: boolean
post:
    result = false


context Note::TogglePinned : FolderNote
post:
    let pinnedLink :FolderNote = user.PinnedFolders.Notes.select(element.Note.Id = self.Id).first
    if pinnedLink <> null then
        pinnedLink.delete
        result = null
    else
        let maxOrder: integer = 0
        if user.PinnedFolders.Notes.count > 0 then
            maxOrder = user.PinnedFolders.Notes.max(element.Order)
        else
            maxOrder = user.PinnedFolders.Folders.max(element.Order)    
        end if

        result = user.PinnedFolders.Notes.newElement(e | e.Note = self and e.Order = maxOrder+ORDER_STEP)
    end if


context Note::IsPinned: boolean
post:
    result = user.PinnedFolders.Notes.exists(element.Note.Id = self.Id)


context Note::CalculateCanonicalPath: string
post:
    let parentPath: JsonObject
    let canonicalPath: JsonObject
    
    let canonicalFolderLink: FolderNote
    let canonicalTaskLink:   TaskNote
    let canonicalNoteLink:   NoteNote
    let parentFolder: Folder
    let parentTask: Task
    let parentNote: Note
   
    canonicalFolderLink = self.InFolders.select(element.IsCanonical).first
    if canonicalFolderLink <> null then
        parentFolder = canonicalFolderLink.Folder
        if not parentFolder.CanonicalPath.isEmpty then
            parentPath = new JsonObject
            parentPath.Parse(parentFolder.CanonicalPath)
            if parentPath.count > 0 then
                canonicalPath = [...parentPath]
            else
                canonicalPath = []
            end if
            canonicalPath = [..., 
                {
                    Name: parentFolder.Title,
                    Summary: parentFolder.Summary,
                    href: parentFolder.href,
                    icon: parentFolder.icon
                }]
        else
            canonicalPath = []
        end if
    else 
        canonicalTaskLink = self.InTasks.select(element.IsCanonical).first
        if canonicalTaskLink <> null then
            parentTask = canonicalTaskLink.Task
            if not parentTask.CanonicalPath.isEmpty then
                parentPath = new JsonObject
                parentPath.Parse(parentTask.CanonicalPath)
                if parentPath.count > 0 then
                    canonicalPath = [...parentPath]
                else
                    canonicalPath = []
                end if
                canonicalPath = [..., 
                    {
                        Name: parentTask.Title,
                        Summary: parentTask.Summary,
                        href: parentTask.href,
                        icon: 'Task'
                    }]
            else
                canonicalPath = []
            end if
        else
            canonicalNoteLink = self.InNotes.select(element.IsCanonical).first
            if canonicalNoteLink <> null then
                parentNote = canonicalNoteLink.InNote
                if not parentNote.CanonicalPath.isEmpty then
                    parentPath = new JsonObject
                    parentPath.Parse(parentNote.CanonicalPath)
                    if parentPath.count > 0 then
                        canonicalPath = [...parentPath]
                    else
                        canonicalPath = []
                    end if
                    canonicalPath = [..., 
                        {
                            Name:       parentNote.Title,
                            Summary:    parentNote.Summary,
                            href:       parentNote.href,
                            icon:       'Note'
                        }]
                else
                    canonicalPath = []
                end if
            else
                canonicalPath = []
            end if
        end if
    end if

    result = canonicalPath.ToString()


context Note::ValidateSubTreeCanonicalPaths
post:
    self.CanonicalPath = self.CalculateCanonicalPath()

    self.Notes.select(element.IsCanonical).forAll(link: NoteNote |
        link.Note.ValidateSubTreeCanonicalPaths()
    )

    self.Files.select(element.IsCanonical).forAll(link: NoteFile |
        link.File.ValidateSubTreeCanonicalPaths()
    )


context Note::RecalculateCanonicalLinksAfterAttach(newLink: FolderNote)
post:
    let changed: boolean = false
    let prevCanonicalLink: FolderNote = self.InFolders.select(element.IsCanonical).first

    let fromFolder: Folder = prevCanonicalLink.Folder
    let toFolder: Folder = newLink.Folder

    if prevCanonicalLink = null then
        newLink.LinkInfo = newLink.LinkInfo | FLI_CANONICAL
        changed = true
    else

        if toFolder.IsPublic then 
            if not fromFolder.IsPublic then
                newLink.LinkInfo = newLink.LinkInfo | FLI_CANONICAL
                prevCanonicalLink.LinkInfo = prevCanonicalLink.LinkInfo & (~FLI_CANONICAL)
                changed = true
            end if
        else
            if toFolder.IsGroupFolder then
                if fromFolder.IsPersonal then
                    newLink.LinkInfo = newLink.LinkInfo | FLI_CANONICAL
                    prevCanonicalLink.LinkInfo = prevCanonicalLink.LinkInfo & (~FLI_CANONICAL)
                    changed = true
                end if
            end if
        end if

    end if

    if changed = true then
        self.ValidateSubTreeCanonicalPaths()
    end if


context Note::GetCanonicalPath: JsonObject
post:
    if not self.CanonicalPath.isEmpty then
        result = new JsonObject
        result.Parse(self.CanonicalPath)
    else
        result = null
    end if


context Note::AttachNote(note: Note, order: integer): boolean
post:
    if not self.Notes.exists(element.Note = note) then
        self.Notes.newElement( element.Note = note and element.Order = order)
        result = true
    else
        result = false
    end if

context Note::AttachFile(f: UploadedFile, order: integer): boolean
post:
    if not self.Files.exists(element.File = f) then
        self.Files.newElement(element.File=f)
        result = true
    else
        result = false
    end if

context Note::AttachClipboard(references: JsonObject): Note
post:
    let referencesNo: integer = references.count
    let maxOrder: integer = self.Notes.max(element.Order)
    let order: integer = maxOrder + ORDER_STEP

    let reference: JsonObject
    let id: integer
    let typeName: string
    let flags: integer

    let note: Note
    let upFile: UploadedFile
    
    set(0 .. referencesNo-1).forAll(i |
        reference = references[i]
        id = reference.id
        typeName = reference.typeName
        flags = reference.flags         -- todo: EIF_CUT handle

        select case typeName
            case 'Note'
                note = system.GetItem(id, typeName)
                if note <> null then
                    if self.AttachNote(note, order) then
                        order = order + ORDER_STEP
                    end if        
                end if

            case 'UploadedFile'
                upFile = system.GetItem(id, typeName)
                if upFile <> null then
                    if self.AttachFile(upFile, order) then
                        order = order + ORDER_STEP
                    end if        
                end if

        end select
    )
    result = self


context Note::CreateFile(title: string, mimeType: string, size: integer, optional order: integer=0) : NoteFile
pre Only logged in users may upload files:
    user <> null
post:
    let upFile: UploadedFile
    let fileLink: NoteFile

    upFile = user.UploadedFiles.newElement(n |  n.Title = title
                                                n.MimeType = mimeType
                                                n.Size = size)

    fileLink = self.Files.newElement( e | 
        e.File = upFile
        e.LinkInfo = FLI_CANONICAL)

    upFile.ValidateSubTreeCanonicalPaths()
    result = fileLink


context Note::CopyNoteToBasket(noteLink: NoteNote, optional flags: integer=0): ElementReference
post:
    result = noteLink.Note.CopyToBasket(flags)

context Note::CutNoteToBasket(noteLink: NoteNote): ElementReference
post:
    result = self.CopyNoteToBasket(noteLink, EIF_CUT)
    self.DettachNote(noteLink)


context Note::CopyFileToBasket(fileLink: NoteFile, optional flags: integer=0): ElementReference
post:
    result = fileLink.File.CopyToBasket(flags)


context Note::CutFileToBasket(fileLink: NoteFile): ElementReference
post:
    result = self.CopyFileToBasket(fileLink, EIF_CUT)
    self.DettachFile(fileLink)


context Note::DettachNote(noteLink: NoteNote)
pre:
    noteLink.InNote.Id = self.Id
post:
    noteLink.delete


context Note::DettachFile(fileLink: NoteFile)
pre:
    fileLink.Note.Id = self.Id
post:
    fileLink.delete

context Note::DeletePermanentlyNote(noteLink: NoteNote)
post:
    let note: Note = noteLink.Note
    note.DeletePermanently()


context Note::DeletePermanentlyFile(fileLink: NoteFile)
post:
    let upFile: UploadedFile = fileLink.File
    upFile.DeletePermanently()


context Note::AttachMeTo(references: JsonObject)
post:
    let referencesNo: integer = references.count

    let reference: JsonObject
    let id: integer
    let typeName: string
    
    let folder: Folder
    let note: Note 
    let task: Task 

    set(0 .. referencesNo-1).forAll(i |
        reference = references[i]
        id = reference.id
        typeName = reference.typeName
        
        select case typeName
            case 'Folder'
                folder = system.GetItem(id, typeName)
                if folder <> null then
                    folder.AttachNote(self)
                end if

            case 'Task'
                task = system.GetItem(id, typeName)
                if task <> null then
                    task.AttachNote(self)
                end if

            case 'Note'
                note = system.GetItem(id, typeName)
                if note <> null then
                    note.AttachNote(self, 0)
                end if

        end select
    )


context Note::CreateSubNote(title: string, optional order: integer=0, optional summary: string = ""): NoteNote
post:
    let note: Note = user.CreatedNotes.newElement(element.Title = title and element.Summary = summary)
    
    if order = 0 then
        order = self.Notes.max(element.Order) + ORDER_STEP
    end if

    result = self.Notes.newElement(element.Note = note and element.Order = order)
    result.SetLocationAsCanonical()


-- ----------------------------------------------------------------------------------------------------------------


constraint NoteNote::Note
    self.NoteId = element.Id


context NoteNote
inv:
    self.Title = self.Note.Title


context NoteNote::SetTitle(value: string)
post:
    self.Note.Title = value


context NoteNote::Summary: string
post:
    result = self.Note.Summary

context NoteNote::SetSummary(value: string)
post:
    self.Note.Summary = value

context NoteNote::href: string
post:
    result = self.Note.href

context NoteNote::NotesCount: integer
post:
    result = self.Note.NotesCount


context NoteNote::IsCanonical: boolean
post:
    result = (self.LinkInfo & FLI_CANONICAL) <> 0

context NoteNote::SetLocationAsCanonical
post:
    self.Note.InFolders.select(element.IsCanonical).forAll(element.LinkInfo = element.LinkInfo & (~FLI_CANONICAL))
    self.Note.InNotes.select(element.IsCanonical).forAll(element.LinkInfo = element.LinkInfo & (~FLI_CANONICAL))
    self.Note.InTasks.select(element.IsCanonical).forAll(element.LinkInfo = element.LinkInfo & (~FLI_CANONICAL))

    self.LinkInfo = self.LinkInfo | FLI_CANONICAL
    self.Note.ValidateSubTreeCanonicalPaths()

context NoteNote::AttachMeTo(references: JsonObject)
post:
    self.Note.AttachMeTo(references)

context NoteNote::InTitle: string
post:
    result = self.InNote.Title

context NoteNote::InSummary: string
post:
    result = self.InNote.Summary

context NoteNote::InHRef: string
post:
    result = self.InNote.href

context NoteNote::InIcon: string
post:
    result = "Note"